// Generated by <a href="http://scalaxb.org/">scalaxb</a>.

import scala.concurrent.{ Future, ExecutionContext }


/**
usage:
val obj = scalaxb.fromXML[.Foo](node)
val document = scalaxb.toXML[.Foo](obj, "foo", .defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(Some("tns") -> "http://hl7.org/fhir",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val _AddressFormat: scalaxb.XMLFormat[Address] = new Default_AddressFormat {}
  implicit lazy val _AgeFormat: scalaxb.XMLFormat[Age] = new Default_AgeFormat {}
  implicit lazy val _AttachmentFormat: scalaxb.XMLFormat[Attachment] = new Default_AttachmentFormat {}
  implicit lazy val _CodeableConceptFormat: scalaxb.XMLFormat[CodeableConcept] = new Default_CodeableConceptFormat {}
  implicit lazy val _CodingFormat: scalaxb.XMLFormat[Coding] = new Default_CodingFormat {}
  implicit lazy val _ContactFormat: scalaxb.XMLFormat[Contact] = new Default_ContactFormat {}
  implicit lazy val _CountFormat: scalaxb.XMLFormat[Count] = new Default_CountFormat {}
  implicit lazy val _DistanceFormat: scalaxb.XMLFormat[Distance] = new Default_DistanceFormat {}
  implicit lazy val _DurationFormat: scalaxb.XMLFormat[Duration] = new Default_DurationFormat {}
  implicit lazy val _ElementableFormat: scalaxb.XMLFormat[Elementable] = new Default_ElementableFormat {}
  implicit lazy val _ElementFormat: scalaxb.XMLFormat[Element] = new Default_ElementFormat {}
  implicit lazy val _ExtensionFormat: scalaxb.XMLFormat[Extension] = new Default_ExtensionFormat {}
  implicit lazy val _HumanNameFormat: scalaxb.XMLFormat[HumanName] = new Default_HumanNameFormat {}
  implicit lazy val _IdentifierFormat: scalaxb.XMLFormat[Identifier] = new Default_IdentifierFormat {}
  implicit lazy val _MoneyFormat: scalaxb.XMLFormat[Money] = new Default_MoneyFormat {}
  implicit lazy val _PeriodFormat: scalaxb.XMLFormat[Period] = new Default_PeriodFormat {}
  implicit lazy val _QuantityableFormat: scalaxb.XMLFormat[Quantityable] = new Default_QuantityableFormat {}
  implicit lazy val _QuantityFormat: scalaxb.XMLFormat[Quantity] = new Default_QuantityFormat {}
  implicit lazy val _RangeTypeFormat: scalaxb.XMLFormat[RangeType] = new Default_RangeTypeFormat {}
  implicit lazy val _RatioFormat: scalaxb.XMLFormat[Ratio] = new Default_RatioFormat {}
  implicit lazy val _RepeatFormat: scalaxb.XMLFormat[Repeat] = new Default_RepeatFormat {}
  implicit lazy val _ResourceReferenceFormat: scalaxb.XMLFormat[ResourceReference] = new Default_ResourceReferenceFormat {}
  implicit lazy val _SampledDataFormat: scalaxb.XMLFormat[SampledData] = new Default_SampledDataFormat {}
  implicit lazy val _ScheduleFormat: scalaxb.XMLFormat[Schedule] = new Default_ScheduleFormat {}
  implicit lazy val _StructurableFormat: scalaxb.XMLFormat[Structurable] = new Default_StructurableFormat {}
  implicit lazy val _StructureFormat: scalaxb.XMLFormat[Structure] = new Default_StructureFormat {}
  implicit lazy val _TypeFormat: scalaxb.XMLFormat[Type] = new Default_TypeFormat {}
  implicit lazy val _Base64BinaryTypeFormat: scalaxb.XMLFormat[Base64BinaryType] = new Default_Base64BinaryTypeFormat {}
  implicit lazy val _BooleanTypeFormat: scalaxb.XMLFormat[BooleanType] = new Default_BooleanTypeFormat {}
  implicit lazy val _CodeFormat: scalaxb.XMLFormat[Code] = new Default_CodeFormat {}
  implicit lazy val _DateFormat: scalaxb.XMLFormat[Date] = new Default_DateFormat {}
  implicit lazy val _DateTimeFormat: scalaxb.XMLFormat[DateTime] = new Default_DateTimeFormat {}
  implicit lazy val _DecimalFormat: scalaxb.XMLFormat[Decimal] = new Default_DecimalFormat {}
  implicit lazy val _IdFormat: scalaxb.XMLFormat[Id] = new Default_IdFormat {}
  implicit lazy val _InstantFormat: scalaxb.XMLFormat[Instant] = new Default_InstantFormat {}
  implicit lazy val _IntegerFormat: scalaxb.XMLFormat[Integer] = new Default_IntegerFormat {}
  implicit lazy val _OidFormat: scalaxb.XMLFormat[Oid] = new Default_OidFormat {}
  implicit lazy val _StringTypeFormat: scalaxb.XMLFormat[StringType] = new Default_StringTypeFormat {}
  implicit lazy val _UriFormat: scalaxb.XMLFormat[Uri] = new Default_UriFormat {}
  implicit lazy val _UuidFormat: scalaxb.XMLFormat[Uuid] = new Default_UuidFormat {}


  implicit val fromAnySchemaType: scala.xml.Elem => Option[scalaxb.DataRecord[Any]] = {elem =>
    import scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("uuid"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Uuid](elem)))
      case (Some("string"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[StringType](elem)))
      case (Some("integer"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Integer](elem)))
      case (Some("id"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Id](elem)))
      case (Some("dateTime"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[DateTime](elem)))
      case (Some("code"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Code](elem)))
      case (Some("base64Binary"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Base64BinaryType](elem)))
      case (Some("Structure"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Structurable](elem)))
      case (Some("SampledData"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[SampledData](elem)))
      case (Some("Repeat"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Repeat](elem)))
      case (Some("Range"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[RangeType](elem)))
      case (Some("Period"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Period](elem)))
      case (Some("Identifier"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Identifier](elem)))
      case (Some("Extension"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Extension](elem)))
      case (Some("Duration"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Duration](elem)))
      case (Some("Count"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Count](elem)))
      case (Some("Coding"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Coding](elem)))
      case (Some("Attachment"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Attachment](elem)))
      case (Some("Address"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Address](elem)))
      case (Some("Age"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Age](elem)))
      case (Some("CodeableConcept"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[CodeableConcept](elem)))
      case (Some("Contact"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Contact](elem)))
      case (Some("Distance"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Distance](elem)))
      case (Some("Element"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Elementable](elem)))
      case (Some("HumanName"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[HumanName](elem)))
      case (Some("Money"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Money](elem)))
      case (Some("Quantity"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Quantityable](elem)))
      case (Some("Ratio"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Ratio](elem)))
      case (Some("ResourceReference"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ResourceReference](elem)))
      case (Some("Schedule"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Schedule](elem)))
      case (Some("Type"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Type](elem)))
      case (Some("boolean"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[BooleanType](elem)))
      case (Some("date"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Date](elem)))
      case (Some("decimal"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Decimal](elem)))
      case (Some("instant"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Instant](elem)))
      case (Some("oid"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Oid](elem)))
      case (Some("uri"), Some("http://hl7.org/fhir") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Uri](elem)))

      case _ => None
    }

  }

  trait Default_AddressFormat extends scalaxb.ElemNameParser[Address] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Address")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Address] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "use")) ~ 
      opt(scalaxb.ElemName(None, "text")) ~ 
      safeRep(scalaxb.ElemName(None, "line")) ~ 
      opt(scalaxb.ElemName(None, "city")) ~ 
      opt(scalaxb.ElemName(None, "state")) ~ 
      opt(scalaxb.ElemName(None, "zip")) ~ 
      opt(scalaxb.ElemName(None, "country")) ~ 
      opt(scalaxb.ElemName(None, "period")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      Address(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[Period](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Address, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Address, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.use map { scalaxb.toXML[Code](_, None, Some("use"), __scope, false) } getOrElse {Nil},
        __obj.text map { scalaxb.toXML[StringType](_, None, Some("text"), __scope, false) } getOrElse {Nil},
        __obj.line flatMap { scalaxb.toXML[StringType](_, None, Some("line"), __scope, false) },
        __obj.city map { scalaxb.toXML[StringType](_, None, Some("city"), __scope, false) } getOrElse {Nil},
        __obj.state map { scalaxb.toXML[StringType](_, None, Some("state"), __scope, false) } getOrElse {Nil},
        __obj.zip map { scalaxb.toXML[StringType](_, None, Some("zip"), __scope, false) } getOrElse {Nil},
        __obj.country map { scalaxb.toXML[StringType](_, None, Some("country"), __scope, false) } getOrElse {Nil},
        __obj.period map { scalaxb.toXML[Period](_, None, Some("period"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AgeFormat extends scalaxb.ElemNameParser[Age] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Age")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Age] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "value")) ~ 
      opt(scalaxb.ElemName(None, "comparator")) ~ 
      opt(scalaxb.ElemName(None, "units")) ~ 
      opt(scalaxb.ElemName(None, "system")) ~ 
      opt(scalaxb.ElemName(None, "code")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Age(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Decimal](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Age, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Age, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.value map { scalaxb.toXML[Decimal](_, None, Some("value"), __scope, false) } getOrElse {Nil},
        __obj.comparator map { scalaxb.toXML[Code](_, None, Some("comparator"), __scope, false) } getOrElse {Nil},
        __obj.units map { scalaxb.toXML[StringType](_, None, Some("units"), __scope, false) } getOrElse {Nil},
        __obj.system map { scalaxb.toXML[Uri](_, None, Some("system"), __scope, false) } getOrElse {Nil},
        __obj.code map { scalaxb.toXML[Code](_, None, Some("code"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AttachmentFormat extends scalaxb.ElemNameParser[Attachment] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Attachment")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Attachment] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      (scalaxb.ElemName(None, "contentType")) ~ 
      opt(scalaxb.ElemName(None, "language")) ~ 
      opt(scalaxb.ElemName(None, "data")) ~ 
      opt(scalaxb.ElemName(None, "url")) ~ 
      opt(scalaxb.ElemName(None, "size")) ~ 
      opt(scalaxb.ElemName(None, "hash")) ~ 
      opt(scalaxb.ElemName(None, "title")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      Attachment(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Code](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[Base64BinaryType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Integer](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[Base64BinaryType](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Attachment, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Attachment, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        scalaxb.toXML[Code](__obj.contentType, None, Some("contentType"), __scope, false),
        __obj.language map { scalaxb.toXML[Code](_, None, Some("language"), __scope, false) } getOrElse {Nil},
        __obj.data map { scalaxb.toXML[Base64BinaryType](_, None, Some("data"), __scope, false) } getOrElse {Nil},
        __obj.url map { scalaxb.toXML[Uri](_, None, Some("url"), __scope, false) } getOrElse {Nil},
        __obj.size map { scalaxb.toXML[Integer](_, None, Some("size"), __scope, false) } getOrElse {Nil},
        __obj.hash map { scalaxb.toXML[Base64BinaryType](_, None, Some("hash"), __scope, false) } getOrElse {Nil},
        __obj.title map { scalaxb.toXML[StringType](_, None, Some("title"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CodeableConceptFormat extends scalaxb.ElemNameParser[CodeableConcept] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("CodeableConcept")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CodeableConcept] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      safeRep(scalaxb.ElemName(None, "coding")) ~ 
      opt(scalaxb.ElemName(None, "text")) ^^
      { case p1 ~ p2 ~ p3 =>
      CodeableConcept(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[Coding](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CodeableConcept, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CodeableConcept, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.coding flatMap { scalaxb.toXML[Coding](_, None, Some("coding"), __scope, false) },
        __obj.text map { scalaxb.toXML[StringType](_, None, Some("text"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CodingFormat extends scalaxb.ElemNameParser[Coding] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Coding")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Coding] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "system")) ~ 
      opt(scalaxb.ElemName(None, "version")) ~ 
      opt(scalaxb.ElemName(None, "code")) ~ 
      opt(scalaxb.ElemName(None, "display")) ~ 
      opt(scalaxb.ElemName(None, "primary")) ~ 
      opt(scalaxb.ElemName(None, "valueSet")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      Coding(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[BooleanType](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Coding, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Coding, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.system map { scalaxb.toXML[Uri](_, None, Some("system"), __scope, false) } getOrElse {Nil},
        __obj.version map { scalaxb.toXML[StringType](_, None, Some("version"), __scope, false) } getOrElse {Nil},
        __obj.code map { scalaxb.toXML[Code](_, None, Some("code"), __scope, false) } getOrElse {Nil},
        __obj.display map { scalaxb.toXML[StringType](_, None, Some("display"), __scope, false) } getOrElse {Nil},
        __obj.primary map { scalaxb.toXML[BooleanType](_, None, Some("primary"), __scope, false) } getOrElse {Nil},
        __obj.valueSet map { scalaxb.toXML[Uri](_, None, Some("valueSet"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ContactFormat extends scalaxb.ElemNameParser[Contact] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Contact")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Contact] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "system")) ~ 
      opt(scalaxb.ElemName(None, "value")) ~ 
      opt(scalaxb.ElemName(None, "use")) ~ 
      opt(scalaxb.ElemName(None, "period")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      Contact(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Period](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Contact, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Contact, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.system map { scalaxb.toXML[Code](_, None, Some("system"), __scope, false) } getOrElse {Nil},
        __obj.value map { scalaxb.toXML[StringType](_, None, Some("value"), __scope, false) } getOrElse {Nil},
        __obj.use map { scalaxb.toXML[Code](_, None, Some("use"), __scope, false) } getOrElse {Nil},
        __obj.period map { scalaxb.toXML[Period](_, None, Some("period"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CountFormat extends scalaxb.ElemNameParser[Count] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Count")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Count] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "value")) ~ 
      opt(scalaxb.ElemName(None, "comparator")) ~ 
      opt(scalaxb.ElemName(None, "units")) ~ 
      opt(scalaxb.ElemName(None, "system")) ~ 
      opt(scalaxb.ElemName(None, "code")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Count(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Decimal](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Count, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Count, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.value map { scalaxb.toXML[Decimal](_, None, Some("value"), __scope, false) } getOrElse {Nil},
        __obj.comparator map { scalaxb.toXML[Code](_, None, Some("comparator"), __scope, false) } getOrElse {Nil},
        __obj.units map { scalaxb.toXML[StringType](_, None, Some("units"), __scope, false) } getOrElse {Nil},
        __obj.system map { scalaxb.toXML[Uri](_, None, Some("system"), __scope, false) } getOrElse {Nil},
        __obj.code map { scalaxb.toXML[Code](_, None, Some("code"), __scope, false) } getOrElse {Nil})

  }

  trait Default_DistanceFormat extends scalaxb.ElemNameParser[Distance] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Distance")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Distance] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "value")) ~ 
      opt(scalaxb.ElemName(None, "comparator")) ~ 
      opt(scalaxb.ElemName(None, "units")) ~ 
      opt(scalaxb.ElemName(None, "system")) ~ 
      opt(scalaxb.ElemName(None, "code")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Distance(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Decimal](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Distance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Distance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.value map { scalaxb.toXML[Decimal](_, None, Some("value"), __scope, false) } getOrElse {Nil},
        __obj.comparator map { scalaxb.toXML[Code](_, None, Some("comparator"), __scope, false) } getOrElse {Nil},
        __obj.units map { scalaxb.toXML[StringType](_, None, Some("units"), __scope, false) } getOrElse {Nil},
        __obj.system map { scalaxb.toXML[Uri](_, None, Some("system"), __scope, false) } getOrElse {Nil},
        __obj.code map { scalaxb.toXML[Code](_, None, Some("code"), __scope, false) } getOrElse {Nil})

  }

  trait Default_DurationFormat extends scalaxb.ElemNameParser[Duration] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Duration")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Duration] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "value")) ~ 
      opt(scalaxb.ElemName(None, "comparator")) ~ 
      opt(scalaxb.ElemName(None, "units")) ~ 
      opt(scalaxb.ElemName(None, "system")) ~ 
      opt(scalaxb.ElemName(None, "code")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Duration(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Decimal](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Duration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Duration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.value map { scalaxb.toXML[Decimal](_, None, Some("value"), __scope, false) } getOrElse {Nil},
        __obj.comparator map { scalaxb.toXML[Code](_, None, Some("comparator"), __scope, false) } getOrElse {Nil},
        __obj.units map { scalaxb.toXML[StringType](_, None, Some("units"), __scope, false) } getOrElse {Nil},
        __obj.system map { scalaxb.toXML[Uri](_, None, Some("system"), __scope, false) } getOrElse {Nil},
        __obj.code map { scalaxb.toXML[Code](_, None, Some("code"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ElementableFormat extends scalaxb.XMLFormat[Elementable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Elementable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://hl7.org/fhir"), Some("uuid")) => Right(scalaxb.fromXML[Uuid](node, stack))
          case (Some("http://hl7.org/fhir"), Some("uri")) => Right(scalaxb.fromXML[Uri](node, stack))
          case (Some("http://hl7.org/fhir"), Some("string")) => Right(scalaxb.fromXML[StringType](node, stack))
          case (Some("http://hl7.org/fhir"), Some("oid")) => Right(scalaxb.fromXML[Oid](node, stack))
          case (Some("http://hl7.org/fhir"), Some("integer")) => Right(scalaxb.fromXML[Integer](node, stack))
          case (Some("http://hl7.org/fhir"), Some("instant")) => Right(scalaxb.fromXML[Instant](node, stack))
          case (Some("http://hl7.org/fhir"), Some("id")) => Right(scalaxb.fromXML[Id](node, stack))
          case (Some("http://hl7.org/fhir"), Some("decimal")) => Right(scalaxb.fromXML[Decimal](node, stack))
          case (Some("http://hl7.org/fhir"), Some("date")) => Right(scalaxb.fromXML[Date](node, stack))
          case (Some("http://hl7.org/fhir"), Some("code")) => Right(scalaxb.fromXML[Code](node, stack))
          case (Some("http://hl7.org/fhir"), Some("boolean")) => Right(scalaxb.fromXML[BooleanType](node, stack))
          case (Some("http://hl7.org/fhir"), Some("base64Binary")) => Right(scalaxb.fromXML[Base64BinaryType](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Extension")) => Right(scalaxb.fromXML[Extension](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Type")) => Right(scalaxb.fromXML[Type](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Structure")) => Right(scalaxb.fromXML[Structurable](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Address")) => Right(scalaxb.fromXML[Address](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Contact")) => Right(scalaxb.fromXML[Contact](node, stack))
          case (Some("http://hl7.org/fhir"), Some("HumanName")) => Right(scalaxb.fromXML[HumanName](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Schedule")) => Right(scalaxb.fromXML[Schedule](node, stack))
          case (Some("http://hl7.org/fhir"), Some("SampledData")) => Right(scalaxb.fromXML[SampledData](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Range")) => Right(scalaxb.fromXML[RangeType](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Period")) => Right(scalaxb.fromXML[Period](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Identifier")) => Right(scalaxb.fromXML[Identifier](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Coding")) => Right(scalaxb.fromXML[Coding](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Attachment")) => Right(scalaxb.fromXML[Attachment](node, stack))
          case (Some("http://hl7.org/fhir"), Some("CodeableConcept")) => Right(scalaxb.fromXML[CodeableConcept](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Quantity")) => Right(scalaxb.fromXML[Quantityable](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Duration")) => Right(scalaxb.fromXML[Duration](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Count")) => Right(scalaxb.fromXML[Count](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Age")) => Right(scalaxb.fromXML[Age](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Distance")) => Right(scalaxb.fromXML[Distance](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Money")) => Right(scalaxb.fromXML[Money](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Ratio")) => Right(scalaxb.fromXML[Ratio](node, stack))
          case (Some("http://hl7.org/fhir"), Some("ResourceReference")) => Right(scalaxb.fromXML[ResourceReference](node, stack))
          case (Some("http://hl7.org/fhir"), Some("dateTime")) => Right(scalaxb.fromXML[DateTime](node, stack))
          case _ => Right(scalaxb.fromXML[Element](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: Elementable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: Uuid => scalaxb.toXML[Uuid](x, __namespace, __elementLabel, __scope, true)
      case x: Uri => scalaxb.toXML[Uri](x, __namespace, __elementLabel, __scope, true)
      case x: StringType => scalaxb.toXML[StringType](x, __namespace, __elementLabel, __scope, true)
      case x: Oid => scalaxb.toXML[Oid](x, __namespace, __elementLabel, __scope, true)
      case x: Integer => scalaxb.toXML[Integer](x, __namespace, __elementLabel, __scope, true)
      case x: Instant => scalaxb.toXML[Instant](x, __namespace, __elementLabel, __scope, true)
      case x: Id => scalaxb.toXML[Id](x, __namespace, __elementLabel, __scope, true)
      case x: Decimal => scalaxb.toXML[Decimal](x, __namespace, __elementLabel, __scope, true)
      case x: Date => scalaxb.toXML[Date](x, __namespace, __elementLabel, __scope, true)
      case x: Code => scalaxb.toXML[Code](x, __namespace, __elementLabel, __scope, true)
      case x: BooleanType => scalaxb.toXML[BooleanType](x, __namespace, __elementLabel, __scope, true)
      case x: Base64BinaryType => scalaxb.toXML[Base64BinaryType](x, __namespace, __elementLabel, __scope, true)
      case x: Extension => scalaxb.toXML[Extension](x, __namespace, __elementLabel, __scope, true)
      case x: Type => scalaxb.toXML[Type](x, __namespace, __elementLabel, __scope, true)
      case x: DateTime => scalaxb.toXML[DateTime](x, __namespace, __elementLabel, __scope, true)
      case x: Element => scalaxb.toXML[Element](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait Default_ElementFormat extends scalaxb.ElemNameParser[Element] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Element")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Element] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Element(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Element, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Element, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_ExtensionFormat extends scalaxb.ElemNameParser[Extension] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Extension")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Extension] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(((scalaxb.ElemName(None, "valueBoolean")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BooleanType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueInteger")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Integer](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueDecimal")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Decimal](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueBase64Binary")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Base64BinaryType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueInstant")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Instant](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueString")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[StringType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueUri")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Uri](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueDate")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Date](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueDateTime")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[DateTime](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueCode")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Code](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueAttachment")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Attachment](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueIdentifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Identifier](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueCodeableConcept")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[CodeableConcept](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueCoding")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Coding](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueQuantity")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Quantityable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueRange")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[RangeType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valuePeriod")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Period](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueRatio")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Ratio](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueResource")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[ResourceReference](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueSampledData")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[SampledData](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueHumanName")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[HumanName](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueAddress")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Address](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueContact")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Contact](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "valueSchedule")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Schedule](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 =>
      Extension(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@url").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@url" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Extension, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@url", _) => __obj.url foreach { x => attr = scala.xml.Attribute(null, "url", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Extension, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.extensionoption map { x => scalaxb.toXML[scalaxb.DataRecord[ExtensionOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil})

  }

  trait Default_HumanNameFormat extends scalaxb.ElemNameParser[HumanName] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("HumanName")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[HumanName] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "use")) ~ 
      opt(scalaxb.ElemName(None, "text")) ~ 
      safeRep(scalaxb.ElemName(None, "family")) ~ 
      safeRep(scalaxb.ElemName(None, "given")) ~ 
      safeRep(scalaxb.ElemName(None, "prefix")) ~ 
      safeRep(scalaxb.ElemName(None, "suffix")) ~ 
      opt(scalaxb.ElemName(None, "period")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      HumanName(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p5 map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p7 map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[Period](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: HumanName, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: HumanName, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.use map { scalaxb.toXML[Code](_, None, Some("use"), __scope, false) } getOrElse {Nil},
        __obj.text map { scalaxb.toXML[StringType](_, None, Some("text"), __scope, false) } getOrElse {Nil},
        __obj.family flatMap { scalaxb.toXML[StringType](_, None, Some("family"), __scope, false) },
        __obj.given flatMap { scalaxb.toXML[StringType](_, None, Some("given"), __scope, false) },
        __obj.prefix flatMap { scalaxb.toXML[StringType](_, None, Some("prefix"), __scope, false) },
        __obj.suffix flatMap { scalaxb.toXML[StringType](_, None, Some("suffix"), __scope, false) },
        __obj.period map { scalaxb.toXML[Period](_, None, Some("period"), __scope, false) } getOrElse {Nil})

  }

  trait Default_IdentifierFormat extends scalaxb.ElemNameParser[Identifier] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Identifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Identifier] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "system")) ~ 
      opt(scalaxb.ElemName(None, "id")) ^^
      { case p1 ~ p2 ~ p3 =>
      Identifier(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Identifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Identifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.system map { scalaxb.toXML[Uri](_, None, Some("system"), __scope, false) } getOrElse {Nil},
        __obj.id map { scalaxb.toXML[StringType](_, None, Some("id"), __scope, false) } getOrElse {Nil})

  }

  trait Default_MoneyFormat extends scalaxb.ElemNameParser[Money] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Money")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Money] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "value")) ~ 
      opt(scalaxb.ElemName(None, "comparator")) ~ 
      opt(scalaxb.ElemName(None, "units")) ~ 
      opt(scalaxb.ElemName(None, "system")) ~ 
      opt(scalaxb.ElemName(None, "code")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Money(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Decimal](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Money, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Money, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.value map { scalaxb.toXML[Decimal](_, None, Some("value"), __scope, false) } getOrElse {Nil},
        __obj.comparator map { scalaxb.toXML[Code](_, None, Some("comparator"), __scope, false) } getOrElse {Nil},
        __obj.units map { scalaxb.toXML[StringType](_, None, Some("units"), __scope, false) } getOrElse {Nil},
        __obj.system map { scalaxb.toXML[Uri](_, None, Some("system"), __scope, false) } getOrElse {Nil},
        __obj.code map { scalaxb.toXML[Code](_, None, Some("code"), __scope, false) } getOrElse {Nil})

  }

  trait Default_PeriodFormat extends scalaxb.ElemNameParser[Period] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Period")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Period] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "start")) ~ 
      opt(scalaxb.ElemName(None, "end")) ^^
      { case p1 ~ p2 ~ p3 =>
      Period(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[DateTime](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[DateTime](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Period, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Period, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.start map { scalaxb.toXML[DateTime](_, None, Some("start"), __scope, false) } getOrElse {Nil},
        __obj.end map { scalaxb.toXML[DateTime](_, None, Some("end"), __scope, false) } getOrElse {Nil})

  }

  trait Default_QuantityableFormat extends scalaxb.XMLFormat[Quantityable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Quantityable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://hl7.org/fhir"), Some("Duration")) => Right(scalaxb.fromXML[Duration](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Count")) => Right(scalaxb.fromXML[Count](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Age")) => Right(scalaxb.fromXML[Age](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Distance")) => Right(scalaxb.fromXML[Distance](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Money")) => Right(scalaxb.fromXML[Money](node, stack))
          case _ => Right(scalaxb.fromXML[Quantity](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: Quantityable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: Duration => scalaxb.toXML[Duration](x, __namespace, __elementLabel, __scope, true)
      case x: Count => scalaxb.toXML[Count](x, __namespace, __elementLabel, __scope, true)
      case x: Age => scalaxb.toXML[Age](x, __namespace, __elementLabel, __scope, true)
      case x: Distance => scalaxb.toXML[Distance](x, __namespace, __elementLabel, __scope, true)
      case x: Money => scalaxb.toXML[Money](x, __namespace, __elementLabel, __scope, true)
      case x: Quantity => scalaxb.toXML[Quantity](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait Default_QuantityFormat extends scalaxb.ElemNameParser[Quantity] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Quantity")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Quantity] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "value")) ~ 
      opt(scalaxb.ElemName(None, "comparator")) ~ 
      opt(scalaxb.ElemName(None, "units")) ~ 
      opt(scalaxb.ElemName(None, "system")) ~ 
      opt(scalaxb.ElemName(None, "code")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Quantity(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Decimal](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Uri](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Quantity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Quantity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.value map { scalaxb.toXML[Decimal](_, None, Some("value"), __scope, false) } getOrElse {Nil},
        __obj.comparator map { scalaxb.toXML[Code](_, None, Some("comparator"), __scope, false) } getOrElse {Nil},
        __obj.units map { scalaxb.toXML[StringType](_, None, Some("units"), __scope, false) } getOrElse {Nil},
        __obj.system map { scalaxb.toXML[Uri](_, None, Some("system"), __scope, false) } getOrElse {Nil},
        __obj.code map { scalaxb.toXML[Code](_, None, Some("code"), __scope, false) } getOrElse {Nil})

  }

  trait Default_RangeTypeFormat extends scalaxb.ElemNameParser[RangeType] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Range")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[RangeType] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "low")) ~ 
      opt(scalaxb.ElemName(None, "high")) ^^
      { case p1 ~ p2 ~ p3 =>
      RangeType(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Quantityable](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Quantityable](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: RangeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RangeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.low map { scalaxb.toXML[Quantityable](_, None, Some("low"), __scope, false) } getOrElse {Nil},
        __obj.high map { scalaxb.toXML[Quantityable](_, None, Some("high"), __scope, false) } getOrElse {Nil})

  }

  trait Default_RatioFormat extends scalaxb.ElemNameParser[Ratio] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Ratio")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Ratio] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "numerator")) ~ 
      opt(scalaxb.ElemName(None, "denominator")) ^^
      { case p1 ~ p2 ~ p3 =>
      Ratio(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Quantityable](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Quantityable](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Ratio, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Ratio, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.numerator map { scalaxb.toXML[Quantityable](_, None, Some("numerator"), __scope, false) } getOrElse {Nil},
        __obj.denominator map { scalaxb.toXML[Quantityable](_, None, Some("denominator"), __scope, false) } getOrElse {Nil})

  }

  trait Default_RepeatFormat extends scalaxb.ElemNameParser[Repeat] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Repeat")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Repeat] =
      phrase(opt(scalaxb.ElemName(None, "frequency")) ~ 
      opt(scalaxb.ElemName(None, "when")) ~ 
      (scalaxb.ElemName(None, "duration")) ~ 
      (scalaxb.ElemName(None, "units")) ~ 
      opt(scalaxb.ElemName(None, "count")) ~ 
      opt(scalaxb.ElemName(None, "end")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Repeat(p1.headOption map { scalaxb.fromXML[Integer](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Decimal](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Code](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Integer](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[DateTime](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Repeat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.frequency map { scalaxb.toXML[Integer](_, None, Some("frequency"), __scope, false) } getOrElse {Nil},
        __obj.when map { scalaxb.toXML[Code](_, None, Some("when"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Decimal](__obj.duration, None, Some("duration"), __scope, false),
        scalaxb.toXML[Code](__obj.units, None, Some("units"), __scope, false),
        __obj.count map { scalaxb.toXML[Integer](_, None, Some("count"), __scope, false) } getOrElse {Nil},
        __obj.end map { scalaxb.toXML[DateTime](_, None, Some("end"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ResourceReferenceFormat extends scalaxb.ElemNameParser[ResourceReference] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("ResourceReference")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ResourceReference] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      opt(scalaxb.ElemName(None, "reference")) ~ 
      opt(scalaxb.ElemName(None, "display")) ^^
      { case p1 ~ p2 ~ p3 =>
      ResourceReference(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[StringType](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ResourceReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ResourceReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.reference map { scalaxb.toXML[StringType](_, None, Some("reference"), __scope, false) } getOrElse {Nil},
        __obj.display map { scalaxb.toXML[StringType](_, None, Some("display"), __scope, false) } getOrElse {Nil})

  }

  trait Default_SampledDataFormat extends scalaxb.ElemNameParser[SampledData] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("SampledData")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SampledData] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      (scalaxb.ElemName(None, "origin")) ~ 
      (scalaxb.ElemName(None, "period")) ~ 
      (scalaxb.ElemName(None, "factor")) ~ 
      opt(scalaxb.ElemName(None, "lowerLimit")) ~ 
      opt(scalaxb.ElemName(None, "upperLimit")) ~ 
      (scalaxb.ElemName(None, "dimensions")) ~ 
      (scalaxb.ElemName(None, "data")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      SampledData(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Quantityable](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Decimal](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Decimal](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Decimal](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Decimal](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Integer](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[StringType](p8, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SampledData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SampledData, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        scalaxb.toXML[Quantityable](__obj.origin, None, Some("origin"), __scope, false),
        scalaxb.toXML[Decimal](__obj.period, None, Some("period"), __scope, false),
        scalaxb.toXML[Decimal](__obj.factor, None, Some("factor"), __scope, false),
        __obj.lowerLimit map { scalaxb.toXML[Decimal](_, None, Some("lowerLimit"), __scope, false) } getOrElse {Nil},
        __obj.upperLimit map { scalaxb.toXML[Decimal](_, None, Some("upperLimit"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Integer](__obj.dimensions, None, Some("dimensions"), __scope, false),
        scalaxb.toXML[StringType](__obj.data, None, Some("data"), __scope, false))

  }

  trait Default_ScheduleFormat extends scalaxb.ElemNameParser[Schedule] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Schedule")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Schedule] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ~ 
      safeRep(scalaxb.ElemName(None, "event")) ~ 
      opt(scalaxb.ElemName(None, "repeat")) ^^
      { case p1 ~ p2 ~ p3 =>
      Schedule(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[Period](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Repeat](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Schedule, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Schedule, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) },
        __obj.event flatMap { scalaxb.toXML[Period](_, None, Some("event"), __scope, false) },
        __obj.repeat map { scalaxb.toXML[Repeat](_, None, Some("repeat"), __scope, false) } getOrElse {Nil})

  }

  trait Default_StructurableFormat extends scalaxb.XMLFormat[Structurable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Structurable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://hl7.org/fhir"), Some("Address")) => Right(scalaxb.fromXML[Address](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Contact")) => Right(scalaxb.fromXML[Contact](node, stack))
          case (Some("http://hl7.org/fhir"), Some("HumanName")) => Right(scalaxb.fromXML[HumanName](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Schedule")) => Right(scalaxb.fromXML[Schedule](node, stack))
          case _ => Right(scalaxb.fromXML[Structure](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: Structurable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: Address => scalaxb.toXML[Address](x, __namespace, __elementLabel, __scope, true)
      case x: Contact => scalaxb.toXML[Contact](x, __namespace, __elementLabel, __scope, true)
      case x: HumanName => scalaxb.toXML[HumanName](x, __namespace, __elementLabel, __scope, true)
      case x: Schedule => scalaxb.toXML[Schedule](x, __namespace, __elementLabel, __scope, true)
      case x: Structure => scalaxb.toXML[Structure](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait Default_StructureFormat extends scalaxb.ElemNameParser[Structure] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("Structure")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Structure] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Structure(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Structure, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Structure, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_TypeFormat extends scalaxb.XMLFormat[Type] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Type] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://hl7.org/fhir"), Some("Structure")) => Right(scalaxb.fromXML[Structurable](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Address")) => Right(scalaxb.fromXML[Address](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Contact")) => Right(scalaxb.fromXML[Contact](node, stack))
          case (Some("http://hl7.org/fhir"), Some("HumanName")) => Right(scalaxb.fromXML[HumanName](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Schedule")) => Right(scalaxb.fromXML[Schedule](node, stack))
          case (Some("http://hl7.org/fhir"), Some("SampledData")) => Right(scalaxb.fromXML[SampledData](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Range")) => Right(scalaxb.fromXML[RangeType](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Period")) => Right(scalaxb.fromXML[Period](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Identifier")) => Right(scalaxb.fromXML[Identifier](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Coding")) => Right(scalaxb.fromXML[Coding](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Attachment")) => Right(scalaxb.fromXML[Attachment](node, stack))
          case (Some("http://hl7.org/fhir"), Some("CodeableConcept")) => Right(scalaxb.fromXML[CodeableConcept](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Quantity")) => Right(scalaxb.fromXML[Quantityable](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Duration")) => Right(scalaxb.fromXML[Duration](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Count")) => Right(scalaxb.fromXML[Count](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Age")) => Right(scalaxb.fromXML[Age](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Distance")) => Right(scalaxb.fromXML[Distance](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Money")) => Right(scalaxb.fromXML[Money](node, stack))
          case (Some("http://hl7.org/fhir"), Some("Ratio")) => Right(scalaxb.fromXML[Ratio](node, stack))
          case (Some("http://hl7.org/fhir"), Some("ResourceReference")) => Right(scalaxb.fromXML[ResourceReference](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: Type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: Structurable => scalaxb.toXML[Structurable](x, __namespace, __elementLabel, __scope, true)
      case x: SampledData => scalaxb.toXML[SampledData](x, __namespace, __elementLabel, __scope, true)
      case x: RangeType => scalaxb.toXML[RangeType](x, __namespace, __elementLabel, __scope, true)
      case x: Period => scalaxb.toXML[Period](x, __namespace, __elementLabel, __scope, true)
      case x: Identifier => scalaxb.toXML[Identifier](x, __namespace, __elementLabel, __scope, true)
      case x: Coding => scalaxb.toXML[Coding](x, __namespace, __elementLabel, __scope, true)
      case x: Attachment => scalaxb.toXML[Attachment](x, __namespace, __elementLabel, __scope, true)
      case x: CodeableConcept => scalaxb.toXML[CodeableConcept](x, __namespace, __elementLabel, __scope, true)
      case x: Quantityable => scalaxb.toXML[Quantityable](x, __namespace, __elementLabel, __scope, true)
      case x: Ratio => scalaxb.toXML[Ratio](x, __namespace, __elementLabel, __scope, true)
      case x: ResourceReference => scalaxb.toXML[ResourceReference](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_Base64BinaryTypeFormat extends scalaxb.ElemNameParser[Base64BinaryType] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("base64Binary")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Base64BinaryType] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Base64BinaryType(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.Base64Binary](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Base64BinaryType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Base64BinaryType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_BooleanTypeFormat extends scalaxb.ElemNameParser[BooleanType] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("boolean")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[BooleanType] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      BooleanType(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: BooleanType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BooleanType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_CodeFormat extends scalaxb.ElemNameParser[Code] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("code")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Code] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Code(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Code, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Code, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_DateFormat extends scalaxb.ElemNameParser[Date] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("date")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Date] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Date(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Date, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Date, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_DateTimeFormat extends scalaxb.ElemNameParser[DateTime] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("dateTime")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[DateTime] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      DateTime(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: DateTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: DateTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_DecimalFormat extends scalaxb.ElemNameParser[Decimal] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("decimal")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Decimal] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Decimal(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Decimal, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.bigDecimal.toPlainString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Decimal, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_IdFormat extends scalaxb.ElemNameParser[Id] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("id")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Id] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Id(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Id, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Id, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_InstantFormat extends scalaxb.ElemNameParser[Instant] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("instant")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Instant] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Instant(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Instant, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Instant, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_IntegerFormat extends scalaxb.ElemNameParser[Integer] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("integer")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Integer] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Integer(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Integer, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Integer, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_OidFormat extends scalaxb.ElemNameParser[Oid] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("oid")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Oid] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Oid(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Oid, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Oid, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_StringTypeFormat extends scalaxb.ElemNameParser[StringType] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("string")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[StringType] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      StringType(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: StringType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: StringType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_UriFormat extends scalaxb.ElemNameParser[Uri] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("uri")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Uri] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Uri(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Uri, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Uri, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }

  trait Default_UuidFormat extends scalaxb.ElemNameParser[Uuid] {
    val targetNamespace: Option[String] = Some("http://hl7.org/fhir")
    
    override def typeName: Option[String] = Some("uuid")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Uuid] =
      phrase(safeRep(scalaxb.ElemName(None, "extension")) ^^
      { case p1 =>
      Uuid(p1 map { scalaxb.fromXML[Extension](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Uuid, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Uuid, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.extension flatMap { scalaxb.toXML[Extension](_, None, Some("extension"), __scope, false) })
  }


}

