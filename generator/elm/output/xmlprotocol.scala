// Generated by <a href="http://scalaxb.org/">scalaxb</a>.

import scala.concurrent.{ Future, ExecutionContext }


/**
usage:
val obj = scalaxb.fromXML[.Foo](node)
val document = scalaxb.toXML[.Foo](obj, "foo", .defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(None -> "urn:hl7-org:elm:r1",
    Some("a") -> "urn:hl7-org:cql-annotations:r1",
    Some("tns") -> "urn:hl7-org:elm:r1",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val _VersionedIdentifierFormat: scalaxb.XMLFormat[VersionedIdentifier] = new Default_VersionedIdentifierFormat {}
  implicit lazy val _UsingDefFormat: scalaxb.XMLFormat[UsingDef] = new Default_UsingDefFormat {}
  implicit lazy val _IncludeDefFormat: scalaxb.XMLFormat[IncludeDef] = new Default_IncludeDefFormat {}
  implicit lazy val _ContextDefFormat: scalaxb.XMLFormat[ContextDef] = new Default_ContextDefFormat {}
  implicit lazy val _UsingsFormat: scalaxb.XMLFormat[Usings] = new Default_UsingsFormat {}
  implicit lazy val _IncludesFormat: scalaxb.XMLFormat[Includes] = new Default_IncludesFormat {}
  implicit lazy val _ParametersFormat: scalaxb.XMLFormat[Parameters] = new Default_ParametersFormat {}
  implicit lazy val _CodeSystemsFormat: scalaxb.XMLFormat[CodeSystems] = new Default_CodeSystemsFormat {}
  implicit lazy val _ValueSetsFormat: scalaxb.XMLFormat[ValueSets] = new Default_ValueSetsFormat {}
  implicit lazy val _CodesFormat: scalaxb.XMLFormat[Codes] = new Default_CodesFormat {}
  implicit lazy val _ConceptsFormat: scalaxb.XMLFormat[Concepts] = new Default_ConceptsFormat {}
  implicit lazy val _ContextsFormat: scalaxb.XMLFormat[Contexts] = new Default_ContextsFormat {}
  implicit lazy val _StatementsFormat: scalaxb.XMLFormat[Statements] = new Default_StatementsFormat {}
  implicit lazy val _LibraryFormat: scalaxb.XMLFormat[Library] = new Default_LibraryFormat {}
  implicit lazy val _CqlToElmBaseFormat: scalaxb.XMLFormat[CqlToElmBase] = new Default_CqlToElmBaseFormat {}
  implicit lazy val _AnnotationFormat: scalaxb.XMLFormat[Annotation] = new Default_AnnotationFormat {}
  implicit lazy val _TagFormat: scalaxb.XMLFormat[Tag] = new Default_TagFormat {}
  implicit lazy val _LocatorableFormat: scalaxb.XMLFormat[Locatorable] = new Default_LocatorableFormat {}
  implicit lazy val _LocatorFormat: scalaxb.XMLFormat[Locator] = new Default_LocatorFormat {}
  implicit lazy val _NarrativeFormat: scalaxb.XMLFormat[Narrative] = new Default_NarrativeFormat {}
  implicit lazy val _ErrorSeverityFormat: scalaxb.XMLFormat[ErrorSeverity] = new Default_ErrorSeverityFormat {}
  implicit lazy val _ErrorTypeFormat: scalaxb.XMLFormat[ErrorType] = new Default_ErrorTypeFormat {}
  implicit lazy val _CqlToElmErrorFormat: scalaxb.XMLFormat[CqlToElmError] = new Default_CqlToElmErrorFormat {}
  implicit lazy val _CqlToElmInfoFormat: scalaxb.XMLFormat[CqlToElmInfo] = new Default_CqlToElmInfoFormat {}
  implicit lazy val _CodeFilterElementFormat: scalaxb.XMLFormat[CodeFilterElement] = new Default_CodeFilterElementFormat {}
  implicit lazy val _DateFilterElementFormat: scalaxb.XMLFormat[DateFilterElement] = new Default_DateFilterElementFormat {}
  implicit lazy val _OtherFilterElementFormat: scalaxb.XMLFormat[OtherFilterElement] = new Default_OtherFilterElementFormat {}
  implicit lazy val _IncludeElementFormat: scalaxb.XMLFormat[IncludeElement] = new Default_IncludeElementFormat {}
  implicit lazy val _RetrieveFormat: scalaxb.XMLFormat[Retrieve] = new Default_RetrieveFormat {}
  implicit lazy val _SearchFormat: scalaxb.XMLFormat[Search] = new Default_SearchFormat {}
  implicit lazy val _CodeSystemDefFormat: scalaxb.XMLFormat[CodeSystemDef] = new Default_CodeSystemDefFormat {}
  implicit lazy val _ValueSetDefFormat: scalaxb.XMLFormat[ValueSetDef] = new Default_ValueSetDefFormat {}
  implicit lazy val _CodeDefFormat: scalaxb.XMLFormat[CodeDef] = new Default_CodeDefFormat {}
  implicit lazy val _ConceptDefFormat: scalaxb.XMLFormat[ConceptDef] = new Default_ConceptDefFormat {}
  implicit lazy val _CodeSystemRefFormat: scalaxb.XMLFormat[CodeSystemRef] = new Default_CodeSystemRefFormat {}
  implicit lazy val _ValueSetRefFormat: scalaxb.XMLFormat[ValueSetRef] = new Default_ValueSetRefFormat {}
  implicit lazy val _CodeRefFormat: scalaxb.XMLFormat[CodeRef] = new Default_CodeRefFormat {}
  implicit lazy val _ConceptRefFormat: scalaxb.XMLFormat[ConceptRef] = new Default_ConceptRefFormat {}
  implicit lazy val _CodeFormat: scalaxb.XMLFormat[Code] = new Default_CodeFormat {}
  implicit lazy val _ConceptFormat: scalaxb.XMLFormat[Concept] = new Default_ConceptFormat {}
  implicit lazy val _InCodeSystemFormat: scalaxb.XMLFormat[InCodeSystem] = new Default_InCodeSystemFormat {}
  implicit lazy val _AnyInCodeSystemFormat: scalaxb.XMLFormat[AnyInCodeSystem] = new Default_AnyInCodeSystemFormat {}
  implicit lazy val _InValueSetFormat: scalaxb.XMLFormat[InValueSet] = new Default_InValueSetFormat {}
  implicit lazy val _AnyInValueSetFormat: scalaxb.XMLFormat[AnyInValueSet] = new Default_AnyInValueSetFormat {}
  implicit lazy val _ExpandValueSetFormat: scalaxb.XMLFormat[ExpandValueSet] = new Default_ExpandValueSetFormat {}
  implicit lazy val _SubsumesFormat: scalaxb.XMLFormat[Subsumes] = new Default_SubsumesFormat {}
  implicit lazy val _SubsumedByFormat: scalaxb.XMLFormat[SubsumedBy] = new Default_SubsumedByFormat {}
  implicit lazy val _QuantityFormat: scalaxb.XMLFormat[Quantity] = new Default_QuantityFormat {}
  implicit lazy val _RatioFormat: scalaxb.XMLFormat[Ratio] = new Default_RatioFormat {}
  implicit lazy val _CalculateAgeFormat: scalaxb.XMLFormat[CalculateAge] = new Default_CalculateAgeFormat {}
  implicit lazy val _CalculateAgeAtFormat: scalaxb.XMLFormat[CalculateAgeAt] = new Default_CalculateAgeAtFormat {}
  implicit lazy val _ElementFormat: scalaxb.XMLFormat[Element] = new Default_ElementFormat {}
  implicit lazy val _TypeSpecifierFormat: scalaxb.XMLFormat[TypeSpecifier] = new Default_TypeSpecifierFormat {}
  implicit lazy val _NamedTypeSpecifierFormat: scalaxb.XMLFormat[NamedTypeSpecifier] = new Default_NamedTypeSpecifierFormat {}
  implicit lazy val _IntervalTypeSpecifierFormat: scalaxb.XMLFormat[IntervalTypeSpecifier] = new Default_IntervalTypeSpecifierFormat {}
  implicit lazy val _ListTypeSpecifierFormat: scalaxb.XMLFormat[ListTypeSpecifier] = new Default_ListTypeSpecifierFormat {}
  implicit lazy val _TupleElementDefinitionFormat: scalaxb.XMLFormat[TupleElementDefinition] = new Default_TupleElementDefinitionFormat {}
  implicit lazy val _TupleTypeSpecifierFormat: scalaxb.XMLFormat[TupleTypeSpecifier] = new Default_TupleTypeSpecifierFormat {}
  implicit lazy val _ChoiceTypeSpecifierFormat: scalaxb.XMLFormat[ChoiceTypeSpecifier] = new Default_ChoiceTypeSpecifierFormat {}
  implicit lazy val _ParameterTypeSpecifierFormat: scalaxb.XMLFormat[ParameterTypeSpecifier] = new Default_ParameterTypeSpecifierFormat {}
  implicit lazy val _ExpressionFormat: scalaxb.XMLFormat[Expression] = new Default_ExpressionFormat {}
  implicit lazy val _OperatorExpressionFormat: scalaxb.XMLFormat[OperatorExpression] = new Default_OperatorExpressionFormat {}
  implicit lazy val _UnaryExpressionFormat: scalaxb.XMLFormat[UnaryExpression] = new Default_UnaryExpressionFormat {}
  implicit lazy val _BinaryExpressionFormat: scalaxb.XMLFormat[BinaryExpression] = new Default_BinaryExpressionFormat {}
  implicit lazy val _TernaryExpressionFormat: scalaxb.XMLFormat[TernaryExpression] = new Default_TernaryExpressionFormat {}
  implicit lazy val _NaryExpressionFormat: scalaxb.XMLFormat[NaryExpression] = new Default_NaryExpressionFormat {}
  implicit lazy val _AccessModifierFormat: scalaxb.XMLFormat[AccessModifier] = new Default_AccessModifierFormat {}
  implicit lazy val _ExpressionDefableFormat: scalaxb.XMLFormat[ExpressionDefable] = new Default_ExpressionDefableFormat {}
  implicit lazy val _ExpressionDefFormat: scalaxb.XMLFormat[ExpressionDef] = new Default_ExpressionDefFormat {}
  implicit lazy val _FunctionDefFormat: scalaxb.XMLFormat[FunctionDef] = new Default_FunctionDefFormat {}
  implicit lazy val _ExpressionRefableFormat: scalaxb.XMLFormat[ExpressionRefable] = new Default_ExpressionRefableFormat {}
  implicit lazy val _ExpressionRefFormat: scalaxb.XMLFormat[ExpressionRef] = new Default_ExpressionRefFormat {}
  implicit lazy val _FunctionRefFormat: scalaxb.XMLFormat[FunctionRef] = new Default_FunctionRefFormat {}
  implicit lazy val _ParameterDefFormat: scalaxb.XMLFormat[ParameterDef] = new Default_ParameterDefFormat {}
  implicit lazy val _ParameterRefFormat: scalaxb.XMLFormat[ParameterRef] = new Default_ParameterRefFormat {}
  implicit lazy val _OperandDefFormat: scalaxb.XMLFormat[OperandDef] = new Default_OperandDefFormat {}
  implicit lazy val _OperandRefFormat: scalaxb.XMLFormat[OperandRef] = new Default_OperandRefFormat {}
  implicit lazy val _IdentifierRefFormat: scalaxb.XMLFormat[IdentifierRef] = new Default_IdentifierRefFormat {}
  implicit lazy val _LiteralFormat: scalaxb.XMLFormat[Literal] = new Default_LiteralFormat {}
  implicit lazy val _TupleElementFormat: scalaxb.XMLFormat[TupleElement] = new Default_TupleElementFormat {}
  implicit lazy val _TupleFormat: scalaxb.XMLFormat[Tuple] = new Default_TupleFormat {}
  implicit lazy val _InstanceElementFormat: scalaxb.XMLFormat[InstanceElement] = new Default_InstanceElementFormat {}
  implicit lazy val _InstanceFormat: scalaxb.XMLFormat[Instance] = new Default_InstanceFormat {}
  implicit lazy val _IntervalFormat: scalaxb.XMLFormat[Interval] = new Default_IntervalFormat {}
  implicit lazy val _ListTypeFormat: scalaxb.XMLFormat[ListType] = new Default_ListTypeFormat {}
  implicit lazy val _AndFormat: scalaxb.XMLFormat[And] = new Default_AndFormat {}
  implicit lazy val _OrFormat: scalaxb.XMLFormat[Or] = new Default_OrFormat {}
  implicit lazy val _XorFormat: scalaxb.XMLFormat[Xor] = new Default_XorFormat {}
  implicit lazy val _ImpliesFormat: scalaxb.XMLFormat[Implies] = new Default_ImpliesFormat {}
  implicit lazy val _NotFormat: scalaxb.XMLFormat[Not] = new Default_NotFormat {}
  implicit lazy val _IfFormat: scalaxb.XMLFormat[If] = new Default_IfFormat {}
  implicit lazy val _CaseItemFormat: scalaxb.XMLFormat[CaseItem] = new Default_CaseItemFormat {}
  implicit lazy val _CaseFormat: scalaxb.XMLFormat[Case] = new Default_CaseFormat {}
  implicit lazy val _NullFormat: scalaxb.XMLFormat[Null] = new Default_NullFormat {}
  implicit lazy val _IsNullFormat: scalaxb.XMLFormat[IsNull] = new Default_IsNullFormat {}
  implicit lazy val _IsTrueFormat: scalaxb.XMLFormat[IsTrue] = new Default_IsTrueFormat {}
  implicit lazy val _IsFalseFormat: scalaxb.XMLFormat[IsFalse] = new Default_IsFalseFormat {}
  implicit lazy val _CoalesceFormat: scalaxb.XMLFormat[Coalesce] = new Default_CoalesceFormat {}
  implicit lazy val _IsFormat: scalaxb.XMLFormat[Is] = new Default_IsFormat {}
  implicit lazy val _AsFormat: scalaxb.XMLFormat[As] = new Default_AsFormat {}
  implicit lazy val _ConvertFormat: scalaxb.XMLFormat[Convert] = new Default_ConvertFormat {}
  implicit lazy val _CanConvertFormat: scalaxb.XMLFormat[CanConvert] = new Default_CanConvertFormat {}
  implicit lazy val _ToBooleanFormat: scalaxb.XMLFormat[ToBoolean] = new Default_ToBooleanFormat {}
  implicit lazy val _ConvertsToBooleanFormat: scalaxb.XMLFormat[ConvertsToBoolean] = new Default_ConvertsToBooleanFormat {}
  implicit lazy val _ToConceptFormat: scalaxb.XMLFormat[ToConcept] = new Default_ToConceptFormat {}
  implicit lazy val _ConvertsToDateFormat: scalaxb.XMLFormat[ConvertsToDate] = new Default_ConvertsToDateFormat {}
  implicit lazy val _ToDateFormat: scalaxb.XMLFormat[ToDate] = new Default_ToDateFormat {}
  implicit lazy val _ConvertsToDateTimeFormat: scalaxb.XMLFormat[ConvertsToDateTime] = new Default_ConvertsToDateTimeFormat {}
  implicit lazy val _ToDateTimeFormat: scalaxb.XMLFormat[ToDateTime] = new Default_ToDateTimeFormat {}
  implicit lazy val _ConvertsToDecimalFormat: scalaxb.XMLFormat[ConvertsToDecimal] = new Default_ConvertsToDecimalFormat {}
  implicit lazy val _ToDecimalFormat: scalaxb.XMLFormat[ToDecimal] = new Default_ToDecimalFormat {}
  implicit lazy val _ConvertsToIntegerFormat: scalaxb.XMLFormat[ConvertsToInteger] = new Default_ConvertsToIntegerFormat {}
  implicit lazy val _ToIntegerFormat: scalaxb.XMLFormat[ToInteger] = new Default_ToIntegerFormat {}
  implicit lazy val _ConvertsToLongFormat: scalaxb.XMLFormat[ConvertsToLong] = new Default_ConvertsToLongFormat {}
  implicit lazy val _ToLongFormat: scalaxb.XMLFormat[ToLong] = new Default_ToLongFormat {}
  implicit lazy val _ConvertsToQuantityFormat: scalaxb.XMLFormat[ConvertsToQuantity] = new Default_ConvertsToQuantityFormat {}
  implicit lazy val _ToQuantityFormat: scalaxb.XMLFormat[ToQuantity] = new Default_ToQuantityFormat {}
  implicit lazy val _ConvertsToRatioFormat: scalaxb.XMLFormat[ConvertsToRatio] = new Default_ConvertsToRatioFormat {}
  implicit lazy val _ToRatioFormat: scalaxb.XMLFormat[ToRatio] = new Default_ToRatioFormat {}
  implicit lazy val _ToListFormat: scalaxb.XMLFormat[ToList] = new Default_ToListFormat {}
  implicit lazy val _ToCharsFormat: scalaxb.XMLFormat[ToChars] = new Default_ToCharsFormat {}
  implicit lazy val _ConvertsToStringFormat: scalaxb.XMLFormat[ConvertsToString] = new Default_ConvertsToStringFormat {}
  implicit lazy val _ToStringFormat: scalaxb.XMLFormat[ToString] = new Default_ToStringFormat {}
  implicit lazy val _ConvertsToTimeFormat: scalaxb.XMLFormat[ConvertsToTime] = new Default_ConvertsToTimeFormat {}
  implicit lazy val _ToTimeFormat: scalaxb.XMLFormat[ToTime] = new Default_ToTimeFormat {}
  implicit lazy val _CanConvertQuantityFormat: scalaxb.XMLFormat[CanConvertQuantity] = new Default_CanConvertQuantityFormat {}
  implicit lazy val _ConvertQuantityFormat: scalaxb.XMLFormat[ConvertQuantity] = new Default_ConvertQuantityFormat {}
  implicit lazy val _EqualFormat: scalaxb.XMLFormat[Equal] = new Default_EqualFormat {}
  implicit lazy val _EquivalentFormat: scalaxb.XMLFormat[Equivalent] = new Default_EquivalentFormat {}
  implicit lazy val _NotEqualFormat: scalaxb.XMLFormat[NotEqual] = new Default_NotEqualFormat {}
  implicit lazy val _LessFormat: scalaxb.XMLFormat[Less] = new Default_LessFormat {}
  implicit lazy val _GreaterFormat: scalaxb.XMLFormat[Greater] = new Default_GreaterFormat {}
  implicit lazy val _LessOrEqualFormat: scalaxb.XMLFormat[LessOrEqual] = new Default_LessOrEqualFormat {}
  implicit lazy val _GreaterOrEqualFormat: scalaxb.XMLFormat[GreaterOrEqual] = new Default_GreaterOrEqualFormat {}
  implicit lazy val _AddFormat: scalaxb.XMLFormat[Add] = new Default_AddFormat {}
  implicit lazy val _SubtractFormat: scalaxb.XMLFormat[Subtract] = new Default_SubtractFormat {}
  implicit lazy val _MultiplyFormat: scalaxb.XMLFormat[Multiply] = new Default_MultiplyFormat {}
  implicit lazy val _DivideFormat: scalaxb.XMLFormat[Divide] = new Default_DivideFormat {}
  implicit lazy val _TruncatedDivideFormat: scalaxb.XMLFormat[TruncatedDivide] = new Default_TruncatedDivideFormat {}
  implicit lazy val _ModuloFormat: scalaxb.XMLFormat[Modulo] = new Default_ModuloFormat {}
  implicit lazy val _CeilingFormat: scalaxb.XMLFormat[Ceiling] = new Default_CeilingFormat {}
  implicit lazy val _FloorFormat: scalaxb.XMLFormat[Floor] = new Default_FloorFormat {}
  implicit lazy val _TruncateFormat: scalaxb.XMLFormat[Truncate] = new Default_TruncateFormat {}
  implicit lazy val _AbsFormat: scalaxb.XMLFormat[Abs] = new Default_AbsFormat {}
  implicit lazy val _NegateFormat: scalaxb.XMLFormat[Negate] = new Default_NegateFormat {}
  implicit lazy val _RoundFormat: scalaxb.XMLFormat[Round] = new Default_RoundFormat {}
  implicit lazy val _LnFormat: scalaxb.XMLFormat[Ln] = new Default_LnFormat {}
  implicit lazy val _ExpFormat: scalaxb.XMLFormat[Exp] = new Default_ExpFormat {}
  implicit lazy val _LogFormat: scalaxb.XMLFormat[Log] = new Default_LogFormat {}
  implicit lazy val _PowerFormat: scalaxb.XMLFormat[Power] = new Default_PowerFormat {}
  implicit lazy val _SuccessorFormat: scalaxb.XMLFormat[Successor] = new Default_SuccessorFormat {}
  implicit lazy val _PredecessorFormat: scalaxb.XMLFormat[Predecessor] = new Default_PredecessorFormat {}
  implicit lazy val _MinValueFormat: scalaxb.XMLFormat[MinValue] = new Default_MinValueFormat {}
  implicit lazy val _MaxValueFormat: scalaxb.XMLFormat[MaxValue] = new Default_MaxValueFormat {}
  implicit lazy val _PrecisionFormat: scalaxb.XMLFormat[Precision] = new Default_PrecisionFormat {}
  implicit lazy val _LowBoundaryFormat: scalaxb.XMLFormat[LowBoundary] = new Default_LowBoundaryFormat {}
  implicit lazy val _HighBoundaryFormat: scalaxb.XMLFormat[HighBoundary] = new Default_HighBoundaryFormat {}
  implicit lazy val _ConcatenateFormat: scalaxb.XMLFormat[Concatenate] = new Default_ConcatenateFormat {}
  implicit lazy val _CombineFormat: scalaxb.XMLFormat[Combine] = new Default_CombineFormat {}
  implicit lazy val _SplitFormat: scalaxb.XMLFormat[Split] = new Default_SplitFormat {}
  implicit lazy val _SplitOnMatchesFormat: scalaxb.XMLFormat[SplitOnMatches] = new Default_SplitOnMatchesFormat {}
  implicit lazy val _LengthFormat: scalaxb.XMLFormat[Length] = new Default_LengthFormat {}
  implicit lazy val _UpperFormat: scalaxb.XMLFormat[Upper] = new Default_UpperFormat {}
  implicit lazy val _LowerFormat: scalaxb.XMLFormat[Lower] = new Default_LowerFormat {}
  implicit lazy val _IndexerFormat: scalaxb.XMLFormat[Indexer] = new Default_IndexerFormat {}
  implicit lazy val _PositionOfFormat: scalaxb.XMLFormat[PositionOf] = new Default_PositionOfFormat {}
  implicit lazy val _LastPositionOfFormat: scalaxb.XMLFormat[LastPositionOf] = new Default_LastPositionOfFormat {}
  implicit lazy val _SubstringFormat: scalaxb.XMLFormat[Substring] = new Default_SubstringFormat {}
  implicit lazy val _StartsWithFormat: scalaxb.XMLFormat[StartsWith] = new Default_StartsWithFormat {}
  implicit lazy val _EndsWithFormat: scalaxb.XMLFormat[EndsWith] = new Default_EndsWithFormat {}
  implicit lazy val _MatchesFormat: scalaxb.XMLFormat[Matches] = new Default_MatchesFormat {}
  implicit lazy val _ReplaceMatchesFormat: scalaxb.XMLFormat[ReplaceMatches] = new Default_ReplaceMatchesFormat {}
  implicit lazy val _DateTimePrecisionFormat: scalaxb.XMLFormat[DateTimePrecision] = new Default_DateTimePrecisionFormat {}
  implicit lazy val _DurationBetweenFormat: scalaxb.XMLFormat[DurationBetween] = new Default_DurationBetweenFormat {}
  implicit lazy val _DifferenceBetweenFormat: scalaxb.XMLFormat[DifferenceBetween] = new Default_DifferenceBetweenFormat {}
  implicit lazy val _DateFromFormat: scalaxb.XMLFormat[DateFrom] = new Default_DateFromFormat {}
  implicit lazy val _TimeFromFormat: scalaxb.XMLFormat[TimeFrom] = new Default_TimeFromFormat {}
  implicit lazy val _TimezoneFromFormat: scalaxb.XMLFormat[TimezoneFrom] = new Default_TimezoneFromFormat {}
  implicit lazy val _TimezoneOffsetFromFormat: scalaxb.XMLFormat[TimezoneOffsetFrom] = new Default_TimezoneOffsetFromFormat {}
  implicit lazy val _DateTimeComponentFromFormat: scalaxb.XMLFormat[DateTimeComponentFrom] = new Default_DateTimeComponentFromFormat {}
  implicit lazy val _TimeOfDayFormat: scalaxb.XMLFormat[TimeOfDay] = new Default_TimeOfDayFormat {}
  implicit lazy val _TodayFormat: scalaxb.XMLFormat[Today] = new Default_TodayFormat {}
  implicit lazy val _NowFormat: scalaxb.XMLFormat[Now] = new Default_NowFormat {}
  implicit lazy val _DateFormat: scalaxb.XMLFormat[Date] = new Default_DateFormat {}
  implicit lazy val _DateTimeFormat: scalaxb.XMLFormat[DateTime] = new Default_DateTimeFormat {}
  implicit lazy val _TimeFormat: scalaxb.XMLFormat[Time] = new Default_TimeFormat {}
  implicit lazy val _SameAsFormat: scalaxb.XMLFormat[SameAs] = new Default_SameAsFormat {}
  implicit lazy val _SameOrBeforeFormat: scalaxb.XMLFormat[SameOrBefore] = new Default_SameOrBeforeFormat {}
  implicit lazy val _SameOrAfterFormat: scalaxb.XMLFormat[SameOrAfter] = new Default_SameOrAfterFormat {}
  implicit lazy val _PointFromFormat: scalaxb.XMLFormat[PointFrom] = new Default_PointFromFormat {}
  implicit lazy val _WidthFormat: scalaxb.XMLFormat[Width] = new Default_WidthFormat {}
  implicit lazy val _SizeFormat: scalaxb.XMLFormat[Size] = new Default_SizeFormat {}
  implicit lazy val _StartFormat: scalaxb.XMLFormat[Start] = new Default_StartFormat {}
  implicit lazy val _EndFormat: scalaxb.XMLFormat[End] = new Default_EndFormat {}
  implicit lazy val _ContainsFormat: scalaxb.XMLFormat[Contains] = new Default_ContainsFormat {}
  implicit lazy val _ProperContainsFormat: scalaxb.XMLFormat[ProperContains] = new Default_ProperContainsFormat {}
  implicit lazy val _InFormat: scalaxb.XMLFormat[In] = new Default_InFormat {}
  implicit lazy val _ProperInFormat: scalaxb.XMLFormat[ProperIn] = new Default_ProperInFormat {}
  implicit lazy val _IncludesTypeFormat: scalaxb.XMLFormat[IncludesType] = new Default_IncludesTypeFormat {}
  implicit lazy val _IncludedInFormat: scalaxb.XMLFormat[IncludedIn] = new Default_IncludedInFormat {}
  implicit lazy val _ProperIncludesFormat: scalaxb.XMLFormat[ProperIncludes] = new Default_ProperIncludesFormat {}
  implicit lazy val _ProperIncludedInFormat: scalaxb.XMLFormat[ProperIncludedIn] = new Default_ProperIncludedInFormat {}
  implicit lazy val _BeforeFormat: scalaxb.XMLFormat[Before] = new Default_BeforeFormat {}
  implicit lazy val _AfterFormat: scalaxb.XMLFormat[After] = new Default_AfterFormat {}
  implicit lazy val _MeetsFormat: scalaxb.XMLFormat[Meets] = new Default_MeetsFormat {}
  implicit lazy val _MeetsBeforeFormat: scalaxb.XMLFormat[MeetsBefore] = new Default_MeetsBeforeFormat {}
  implicit lazy val _MeetsAfterFormat: scalaxb.XMLFormat[MeetsAfter] = new Default_MeetsAfterFormat {}
  implicit lazy val _OverlapsFormat: scalaxb.XMLFormat[Overlaps] = new Default_OverlapsFormat {}
  implicit lazy val _OverlapsBeforeFormat: scalaxb.XMLFormat[OverlapsBefore] = new Default_OverlapsBeforeFormat {}
  implicit lazy val _OverlapsAfterFormat: scalaxb.XMLFormat[OverlapsAfter] = new Default_OverlapsAfterFormat {}
  implicit lazy val _StartsFormat: scalaxb.XMLFormat[Starts] = new Default_StartsFormat {}
  implicit lazy val _EndsFormat: scalaxb.XMLFormat[Ends] = new Default_EndsFormat {}
  implicit lazy val _CollapseFormat: scalaxb.XMLFormat[Collapse] = new Default_CollapseFormat {}
  implicit lazy val _ExpandFormat: scalaxb.XMLFormat[Expand] = new Default_ExpandFormat {}
  implicit lazy val _UnionFormat: scalaxb.XMLFormat[Union] = new Default_UnionFormat {}
  implicit lazy val _IntersectFormat: scalaxb.XMLFormat[Intersect] = new Default_IntersectFormat {}
  implicit lazy val _ExceptFormat: scalaxb.XMLFormat[Except] = new Default_ExceptFormat {}
  implicit lazy val _ExistsFormat: scalaxb.XMLFormat[Exists] = new Default_ExistsFormat {}
  implicit lazy val _TimesFormat: scalaxb.XMLFormat[Times] = new Default_TimesFormat {}
  implicit lazy val _FilterFormat: scalaxb.XMLFormat[Filter] = new Default_FilterFormat {}
  implicit lazy val _FirstFormat: scalaxb.XMLFormat[First] = new Default_FirstFormat {}
  implicit lazy val _LastFormat: scalaxb.XMLFormat[Last] = new Default_LastFormat {}
  implicit lazy val _SliceFormat: scalaxb.XMLFormat[Slice] = new Default_SliceFormat {}
  implicit lazy val _IndexOfFormat: scalaxb.XMLFormat[IndexOf] = new Default_IndexOfFormat {}
  implicit lazy val _FlattenFormat: scalaxb.XMLFormat[Flatten] = new Default_FlattenFormat {}
  implicit lazy val _SortFormat: scalaxb.XMLFormat[Sort] = new Default_SortFormat {}
  implicit lazy val _ForEachFormat: scalaxb.XMLFormat[ForEach] = new Default_ForEachFormat {}
  implicit lazy val _RepeatFormat: scalaxb.XMLFormat[Repeat] = new Default_RepeatFormat {}
  implicit lazy val _DistinctFormat: scalaxb.XMLFormat[Distinct] = new Default_DistinctFormat {}
  implicit lazy val _CurrentFormat: scalaxb.XMLFormat[Current] = new Default_CurrentFormat {}
  implicit lazy val _IterationFormat: scalaxb.XMLFormat[Iteration] = new Default_IterationFormat {}
  implicit lazy val _TotalFormat: scalaxb.XMLFormat[Total] = new Default_TotalFormat {}
  implicit lazy val _SingletonFromFormat: scalaxb.XMLFormat[SingletonFrom] = new Default_SingletonFromFormat {}
  implicit lazy val _AggregateExpressionFormat: scalaxb.XMLFormat[AggregateExpression] = new Default_AggregateExpressionFormat {}
  implicit lazy val _AggregateFormat: scalaxb.XMLFormat[Aggregate] = new Default_AggregateFormat {}
  implicit lazy val _CountFormat: scalaxb.XMLFormat[Count] = new Default_CountFormat {}
  implicit lazy val _SumFormat: scalaxb.XMLFormat[Sum] = new Default_SumFormat {}
  implicit lazy val _ProductTypeFormat: scalaxb.XMLFormat[ProductType] = new Default_ProductTypeFormat {}
  implicit lazy val _MinFormat: scalaxb.XMLFormat[Min] = new Default_MinFormat {}
  implicit lazy val _MaxFormat: scalaxb.XMLFormat[Max] = new Default_MaxFormat {}
  implicit lazy val _AvgFormat: scalaxb.XMLFormat[Avg] = new Default_AvgFormat {}
  implicit lazy val _GeometricMeanFormat: scalaxb.XMLFormat[GeometricMean] = new Default_GeometricMeanFormat {}
  implicit lazy val _MedianFormat: scalaxb.XMLFormat[Median] = new Default_MedianFormat {}
  implicit lazy val _ModeFormat: scalaxb.XMLFormat[Mode] = new Default_ModeFormat {}
  implicit lazy val _VarianceFormat: scalaxb.XMLFormat[Variance] = new Default_VarianceFormat {}
  implicit lazy val _PopulationVarianceFormat: scalaxb.XMLFormat[PopulationVariance] = new Default_PopulationVarianceFormat {}
  implicit lazy val _StdDevFormat: scalaxb.XMLFormat[StdDev] = new Default_StdDevFormat {}
  implicit lazy val _PopulationStdDevFormat: scalaxb.XMLFormat[PopulationStdDev] = new Default_PopulationStdDevFormat {}
  implicit lazy val _AllTrueFormat: scalaxb.XMLFormat[AllTrue] = new Default_AllTrueFormat {}
  implicit lazy val _AnyTrueFormat: scalaxb.XMLFormat[AnyTrue] = new Default_AnyTrueFormat {}
  implicit lazy val _PropertyableFormat: scalaxb.XMLFormat[Propertyable] = new Default_PropertyableFormat {}
  implicit lazy val _PropertyFormat: scalaxb.XMLFormat[Property] = new Default_PropertyFormat {}
  implicit lazy val _AliasedQuerySourcableFormat: scalaxb.XMLFormat[AliasedQuerySourcable] = new Default_AliasedQuerySourcableFormat {}
  implicit lazy val _AliasedQuerySourceFormat: scalaxb.XMLFormat[AliasedQuerySource] = new Default_AliasedQuerySourceFormat {}
  implicit lazy val _LetClauseFormat: scalaxb.XMLFormat[LetClause] = new Default_LetClauseFormat {}
  implicit lazy val _RelationshipClauseFormat: scalaxb.XMLFormat[RelationshipClause] = new Default_RelationshipClauseFormat {}
  implicit lazy val _WithFormat: scalaxb.XMLFormat[With] = new Default_WithFormat {}
  implicit lazy val _WithoutFormat: scalaxb.XMLFormat[Without] = new Default_WithoutFormat {}
  implicit lazy val _SortDirectionFormat: scalaxb.XMLFormat[SortDirection] = new Default_SortDirectionFormat {}
  implicit lazy val _SortByItemFormat: scalaxb.XMLFormat[SortByItem] = new Default_SortByItemFormat {}
  implicit lazy val _ByDirectionFormat: scalaxb.XMLFormat[ByDirection] = new Default_ByDirectionFormat {}
  implicit lazy val _ByColumnFormat: scalaxb.XMLFormat[ByColumn] = new Default_ByColumnFormat {}
  implicit lazy val _ByExpressionFormat: scalaxb.XMLFormat[ByExpression] = new Default_ByExpressionFormat {}
  implicit lazy val _SortClauseFormat: scalaxb.XMLFormat[SortClause] = new Default_SortClauseFormat {}
  implicit lazy val _ReturnClauseFormat: scalaxb.XMLFormat[ReturnClause] = new Default_ReturnClauseFormat {}
  implicit lazy val _AggregateClauseFormat: scalaxb.XMLFormat[AggregateClause] = new Default_AggregateClauseFormat {}
  implicit lazy val _QueryFormat: scalaxb.XMLFormat[Query] = new Default_QueryFormat {}
  implicit lazy val _AliasRefFormat: scalaxb.XMLFormat[AliasRef] = new Default_AliasRefFormat {}
  implicit lazy val _QueryLetRefFormat: scalaxb.XMLFormat[QueryLetRef] = new Default_QueryLetRefFormat {}
  implicit lazy val _ChildrenFormat: scalaxb.XMLFormat[Children] = new Default_ChildrenFormat {}
  implicit lazy val _DescendentsFormat: scalaxb.XMLFormat[Descendents] = new Default_DescendentsFormat {}
  implicit lazy val _MessageFormat: scalaxb.XMLFormat[Message] = new Default_MessageFormat {}


  implicit val fromAnySchemaType: scala.xml.Elem => Option[scalaxb.DataRecord[Any]] = {elem =>
    import scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("library"), Some("urn:hl7-org:elm:r1") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[Library](elem)))

      case _ => None
    }

  }

  trait Default_VersionedIdentifierFormat extends scalaxb.XMLFormat[VersionedIdentifier] with scalaxb.CanWriteChildNodes[VersionedIdentifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, VersionedIdentifier] = seq match {
      case node: scala.xml.Node => Right(VersionedIdentifier(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@system").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@system" -> _ },
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: VersionedIdentifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@system", _) => __obj.system foreach { x => attr = scala.xml.Attribute(null, "system", x.toString, attr) }
        case ("@version", _) => __obj.version foreach { x => attr = scala.xml.Attribute(null, "version", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: VersionedIdentifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_UsingDefFormat extends scalaxb.ElemNameParser[UsingDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("UsingDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[UsingDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      UsingDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@localIdentifier").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localIdentifier" -> _ },
        (node \ "@uri").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@uri" -> _ },
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: UsingDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@localIdentifier", _) => attr = scala.xml.Attribute(null, "localIdentifier", __obj.localIdentifier.toString, attr)
        case ("@uri", _) => attr = scala.xml.Attribute(null, "uri", __obj.uri.toString, attr)
        case ("@version", _) => __obj.version foreach { x => attr = scala.xml.Attribute(null, "version", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: UsingDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_IncludeDefFormat extends scalaxb.ElemNameParser[IncludeDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("IncludeDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IncludeDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      IncludeDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@localIdentifier").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localIdentifier" -> _ },
        (node \ "@mediaType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[java.net.URI](scala.xml.Text("application/elm+xml"), scalaxb.ElemName(node) :: stack))) map { "@mediaType" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ },
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IncludeDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@localIdentifier", _) => attr = scala.xml.Attribute(null, "localIdentifier", __obj.localIdentifier.toString, attr)
        case ("@mediaType", _) => if (__obj.mediaType.toString != "application/elm+xml") attr = scala.xml.Attribute(null, "mediaType", __obj.mediaType.toString, attr)
        case ("@path", _) => attr = scala.xml.Attribute(null, "path", __obj.path.toString, attr)
        case ("@version", _) => __obj.version foreach { x => attr = scala.xml.Attribute(null, "version", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IncludeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ContextDefFormat extends scalaxb.ElemNameParser[ContextDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ContextDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ContextDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ContextDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ContextDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ContextDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_UsingsFormat extends scalaxb.ElemNameParser[Usings] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Usings] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "def")) ^^
      { case p1 =>
      Usings(p1 map { scalaxb.fromXML[UsingDef](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Usings, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.defValue flatMap { scalaxb.toXML[UsingDef](_, Some("urn:hl7-org:elm:r1"), Some("def"), __scope, false) })
  }
  trait Default_IncludesFormat extends scalaxb.ElemNameParser[Includes] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Includes] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "def")) ^^
      { case p1 =>
      Includes(p1 map { scalaxb.fromXML[IncludeDef](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Includes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.defValue flatMap { scalaxb.toXML[IncludeDef](_, Some("urn:hl7-org:elm:r1"), Some("def"), __scope, false) })
  }
  trait Default_ParametersFormat extends scalaxb.ElemNameParser[Parameters] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Parameters] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "def")) ^^
      { case p1 =>
      Parameters(p1 map { scalaxb.fromXML[ParameterDef](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Parameters, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.defValue flatMap { scalaxb.toXML[ParameterDef](_, Some("urn:hl7-org:elm:r1"), Some("def"), __scope, false) })
  }
  trait Default_CodeSystemsFormat extends scalaxb.ElemNameParser[CodeSystems] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CodeSystems] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "def")) ^^
      { case p1 =>
      CodeSystems(p1 map { scalaxb.fromXML[CodeSystemDef](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: CodeSystems, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.defValue flatMap { scalaxb.toXML[CodeSystemDef](_, Some("urn:hl7-org:elm:r1"), Some("def"), __scope, false) })
  }
  trait Default_ValueSetsFormat extends scalaxb.ElemNameParser[ValueSets] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ValueSets] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "def")) ^^
      { case p1 =>
      ValueSets(p1 map { scalaxb.fromXML[ValueSetDef](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ValueSets, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.defValue flatMap { scalaxb.toXML[ValueSetDef](_, Some("urn:hl7-org:elm:r1"), Some("def"), __scope, false) })
  }
  trait Default_CodesFormat extends scalaxb.ElemNameParser[Codes] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Codes] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "def")) ^^
      { case p1 =>
      Codes(p1 map { scalaxb.fromXML[CodeDef](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Codes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.defValue flatMap { scalaxb.toXML[CodeDef](_, Some("urn:hl7-org:elm:r1"), Some("def"), __scope, false) })
  }
  trait Default_ConceptsFormat extends scalaxb.ElemNameParser[Concepts] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Concepts] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "def")) ^^
      { case p1 =>
      Concepts(p1 map { scalaxb.fromXML[ConceptDef](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Concepts, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.defValue flatMap { scalaxb.toXML[ConceptDef](_, Some("urn:hl7-org:elm:r1"), Some("def"), __scope, false) })
  }
  trait Default_ContextsFormat extends scalaxb.ElemNameParser[Contexts] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Contexts] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "def")) ^^
      { case p1 =>
      Contexts(p1 map { scalaxb.fromXML[ContextDef](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Contexts, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.defValue flatMap { scalaxb.toXML[ContextDef](_, Some("urn:hl7-org:elm:r1"), Some("def"), __scope, false) })
  }
  trait Default_StatementsFormat extends scalaxb.ElemNameParser[Statements] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Statements] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "def")) ^^
      { case p1 =>
      Statements(p1 map { scalaxb.fromXML[ExpressionDefable](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Statements, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.defValue flatMap { scalaxb.toXML[ExpressionDefable](_, Some("urn:hl7-org:elm:r1"), Some("def"), __scope, false) })
  }
  trait Default_LibraryFormat extends scalaxb.ElemNameParser[Library] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Library")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Library] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "identifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "schemaIdentifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "usings")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "includes")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "parameters")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codeSystems")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "valueSets")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codes")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "concepts")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "contexts")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "statements")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 =>
      Library(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[VersionedIdentifier](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[VersionedIdentifier](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Usings](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Includes](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[Parameters](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[CodeSystems](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[ValueSets](_, scalaxb.ElemName(node) :: stack) },
        p10.headOption map { scalaxb.fromXML[Codes](_, scalaxb.ElemName(node) :: stack) },
        p11.headOption map { scalaxb.fromXML[Concepts](_, scalaxb.ElemName(node) :: stack) },
        p12.headOption map { scalaxb.fromXML[Contexts](_, scalaxb.ElemName(node) :: stack) },
        p13.headOption map { scalaxb.fromXML[Statements](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Library, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Library, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[VersionedIdentifier](__obj.identifier, Some("urn:hl7-org:elm:r1"), Some("identifier"), __scope, false),
        scalaxb.toXML[VersionedIdentifier](__obj.schemaIdentifier, Some("urn:hl7-org:elm:r1"), Some("schemaIdentifier"), __scope, false),
        __obj.usings map { scalaxb.toXML[Usings](_, Some("urn:hl7-org:elm:r1"), Some("usings"), __scope, false) } getOrElse {Nil},
        __obj.includes map { scalaxb.toXML[Includes](_, Some("urn:hl7-org:elm:r1"), Some("includes"), __scope, false) } getOrElse {Nil},
        __obj.parameters map { scalaxb.toXML[Parameters](_, Some("urn:hl7-org:elm:r1"), Some("parameters"), __scope, false) } getOrElse {Nil},
        __obj.codeSystems map { scalaxb.toXML[CodeSystems](_, Some("urn:hl7-org:elm:r1"), Some("codeSystems"), __scope, false) } getOrElse {Nil},
        __obj.valueSets map { scalaxb.toXML[ValueSets](_, Some("urn:hl7-org:elm:r1"), Some("valueSets"), __scope, false) } getOrElse {Nil},
        __obj.codes map { scalaxb.toXML[Codes](_, Some("urn:hl7-org:elm:r1"), Some("codes"), __scope, false) } getOrElse {Nil},
        __obj.concepts map { scalaxb.toXML[Concepts](_, Some("urn:hl7-org:elm:r1"), Some("concepts"), __scope, false) } getOrElse {Nil},
        __obj.contexts map { scalaxb.toXML[Contexts](_, Some("urn:hl7-org:elm:r1"), Some("contexts"), __scope, false) } getOrElse {Nil},
        __obj.statements map { scalaxb.toXML[Statements](_, Some("urn:hl7-org:elm:r1"), Some("statements"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CqlToElmBaseFormat extends scalaxb.XMLFormat[CqlToElmBase] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, CqlToElmBase] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:cql-annotations:r1"), Some("Locator")) => Right(scalaxb.fromXML[Locatorable](node, stack))
          case (Some("urn:hl7-org:cql-annotations:r1"), Some("CqlToElmError")) => Right(scalaxb.fromXML[CqlToElmError](node, stack))
          case (Some("urn:hl7-org:cql-annotations:r1"), Some("Annotation")) => Right(scalaxb.fromXML[Annotation](node, stack))
          case (Some("urn:hl7-org:cql-annotations:r1"), Some("CqlToElmInfo")) => Right(scalaxb.fromXML[CqlToElmInfo](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: CqlToElmBase, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: Locatorable => scalaxb.toXML[Locatorable](x, __namespace, __elementLabel, __scope, true)
      case x: Annotation => scalaxb.toXML[Annotation](x, __namespace, __elementLabel, __scope, true)
      case x: CqlToElmInfo => scalaxb.toXML[CqlToElmInfo](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_AnnotationFormat extends scalaxb.ElemNameParser[Annotation] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:cql-annotations:r1")
    
    override def typeName: Option[String] = Some("Annotation")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Annotation] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:cql-annotations:r1"), "t")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:cql-annotations:r1"), "s")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:cql-annotations:r1"), "locator")) ^^
      { case p1 ~ p2 ~ p3 =>
      Annotation(p1 map { scalaxb.fromXML[Tag](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[Narrative](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Locatorable](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: Annotation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.t flatMap { scalaxb.toXML[Tag](_, Some("urn:hl7-org:cql-annotations:r1"), Some("t"), __scope, false) },
        __obj.s map { scalaxb.toXML[Narrative](_, Some("urn:hl7-org:cql-annotations:r1"), Some("s"), __scope, false) } getOrElse {Nil},
        __obj.locator map { scalaxb.toXML[Locatorable](_, Some("urn:hl7-org:cql-annotations:r1"), Some("locator"), __scope, false) } getOrElse {Nil})

  }

  trait Default_TagFormat extends scalaxb.XMLFormat[Tag] with scalaxb.CanWriteChildNodes[Tag] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:cql-annotations:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Tag] = seq match {
      case node: scala.xml.Node => Right(Tag(scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Tag, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Tag, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_LocatorableFormat extends scalaxb.XMLFormat[Locatorable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Locatorable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:cql-annotations:r1"), Some("CqlToElmError")) => Right(scalaxb.fromXML[CqlToElmError](node, stack))
          case _ => Right(scalaxb.fromXML[Locator](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: Locatorable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: CqlToElmError => scalaxb.toXML[CqlToElmError](x, __namespace, __elementLabel, __scope, true)
      case x: Locator => scalaxb.toXML[Locator](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_LocatorFormat extends scalaxb.XMLFormat[Locator] with scalaxb.CanWriteChildNodes[Locator] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:cql-annotations:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Locator] = seq match {
      case node: scala.xml.Node => Right(Locator(scala.collection.immutable.ListMap(List(
        (node \ "@librarySystem").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@librarySystem" -> _ },
        (node \ "@libraryId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryId" -> _ },
        (node \ "@libraryVersion").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryVersion" -> _ },
        (node \ "@startLine").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@startLine" -> _ },
        (node \ "@startChar").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@startChar" -> _ },
        (node \ "@endLine").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@endLine" -> _ },
        (node \ "@endChar").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@endChar" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: Locator, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@librarySystem", _) => __obj.librarySystem foreach { x => attr = scala.xml.Attribute(null, "librarySystem", x.toString, attr) }
        case ("@libraryId", _) => __obj.libraryId foreach { x => attr = scala.xml.Attribute(null, "libraryId", x.toString, attr) }
        case ("@libraryVersion", _) => __obj.libraryVersion foreach { x => attr = scala.xml.Attribute(null, "libraryVersion", x.toString, attr) }
        case ("@startLine", _) => __obj.startLine foreach { x => attr = scala.xml.Attribute(null, "startLine", x.toString, attr) }
        case ("@startChar", _) => __obj.startChar foreach { x => attr = scala.xml.Attribute(null, "startChar", x.toString, attr) }
        case ("@endLine", _) => __obj.endLine foreach { x => attr = scala.xml.Attribute(null, "endLine", x.toString, attr) }
        case ("@endChar", _) => __obj.endChar foreach { x => attr = scala.xml.Attribute(null, "endChar", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Locator, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_NarrativeFormat extends scalaxb.ElemNameParser[Narrative] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:cql-annotations:r1")
    
    override def typeName: Option[String] = Some("Narrative")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Narrative] =
      phrase(optTextRecord ~ 
      (safeRep(scalaxb.ElemName(Some("urn:hl7-org:cql-annotations:r1"), "s")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[Narrative](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      Narrative(Seq.concat(p1.toList,
        p2,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@r").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@r" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Narrative, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@r", _) => __obj.r foreach { x => attr = scala.xml.Attribute(null, "r", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Narrative, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  def build_ErrorSeverityFormat = new Default_ErrorSeverityFormat {}
  trait Default_ErrorSeverityFormat extends scalaxb.XMLFormat[ErrorSeverity] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:cql-annotations:r1")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): ErrorSeverity =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, ErrorSeverity] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("info")) => Info
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("warning")) => Warning
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("error")) => Error

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ErrorSeverity] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ErrorSeverity, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def build_ErrorTypeFormat = new Default_ErrorTypeFormat {}
  trait Default_ErrorTypeFormat extends scalaxb.XMLFormat[ErrorType] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:cql-annotations:r1")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): ErrorType =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, ErrorType] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("environment")) => Environment
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("syntax")) => Syntax
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("include")) => Include
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("semantic")) => Semantic
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("internal")) => Internal

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ErrorType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: ErrorType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_CqlToElmErrorFormat extends scalaxb.XMLFormat[CqlToElmError] with scalaxb.CanWriteChildNodes[CqlToElmError] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:cql-annotations:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, CqlToElmError] = seq match {
      case node: scala.xml.Node => Right(CqlToElmError(scala.collection.immutable.ListMap(List(
        (node \ "@librarySystem").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@librarySystem" -> _ },
        (node \ "@libraryId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryId" -> _ },
        (node \ "@libraryVersion").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryVersion" -> _ },
        (node \ "@startLine").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@startLine" -> _ },
        (node \ "@startChar").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@startChar" -> _ },
        (node \ "@endLine").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@endLine" -> _ },
        (node \ "@endChar").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@endChar" -> _ },
        (node \ "@message").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@message" -> _ },
        (node \ "@errorType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[ErrorType](x, scalaxb.ElemName(node) :: stack)) } map { "@errorType" -> _ },
        (node \ "@errorSeverity").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[ErrorSeverity](x, scalaxb.ElemName(node) :: stack)) } map { "@errorSeverity" -> _ },
        (node \ "@targetIncludeLibrarySystem").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@targetIncludeLibrarySystem" -> _ },
        (node \ "@targetIncludeLibraryId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@targetIncludeLibraryId" -> _ },
        (node \ "@targetIncludeLibraryVersionId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@targetIncludeLibraryVersionId" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: CqlToElmError, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@librarySystem", _) => __obj.librarySystem foreach { x => attr = scala.xml.Attribute(null, "librarySystem", x.toString, attr) }
        case ("@libraryId", _) => __obj.libraryId foreach { x => attr = scala.xml.Attribute(null, "libraryId", x.toString, attr) }
        case ("@libraryVersion", _) => __obj.libraryVersion foreach { x => attr = scala.xml.Attribute(null, "libraryVersion", x.toString, attr) }
        case ("@startLine", _) => __obj.startLine foreach { x => attr = scala.xml.Attribute(null, "startLine", x.toString, attr) }
        case ("@startChar", _) => __obj.startChar foreach { x => attr = scala.xml.Attribute(null, "startChar", x.toString, attr) }
        case ("@endLine", _) => __obj.endLine foreach { x => attr = scala.xml.Attribute(null, "endLine", x.toString, attr) }
        case ("@endChar", _) => __obj.endChar foreach { x => attr = scala.xml.Attribute(null, "endChar", x.toString, attr) }
        case ("@message", _) => attr = scala.xml.Attribute(null, "message", __obj.message.toString, attr)
        case ("@errorType", _) => attr = scala.xml.Attribute(null, "errorType", __obj.errorType.toString, attr)
        case ("@errorSeverity", _) => __obj.errorSeverity foreach { x => attr = scala.xml.Attribute(null, "errorSeverity", x.toString, attr) }
        case ("@targetIncludeLibrarySystem", _) => __obj.targetIncludeLibrarySystem foreach { x => attr = scala.xml.Attribute(null, "targetIncludeLibrarySystem", x.toString, attr) }
        case ("@targetIncludeLibraryId", _) => __obj.targetIncludeLibraryId foreach { x => attr = scala.xml.Attribute(null, "targetIncludeLibraryId", x.toString, attr) }
        case ("@targetIncludeLibraryVersionId", _) => __obj.targetIncludeLibraryVersionId foreach { x => attr = scala.xml.Attribute(null, "targetIncludeLibraryVersionId", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CqlToElmError, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_CqlToElmInfoFormat extends scalaxb.XMLFormat[CqlToElmInfo] with scalaxb.CanWriteChildNodes[CqlToElmInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:cql-annotations:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, CqlToElmInfo] = seq match {
      case node: scala.xml.Node => Right(CqlToElmInfo(scala.collection.immutable.ListMap(List(
        (node \ "@translatorVersion").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@translatorVersion" -> _ },
        (node \ "@translatorOptions").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@translatorOptions" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: CqlToElmInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@translatorVersion", _) => __obj.translatorVersion foreach { x => attr = scala.xml.Attribute(null, "translatorVersion", x.toString, attr) }
        case ("@translatorOptions", _) => __obj.translatorOptions foreach { x => attr = scala.xml.Attribute(null, "translatorOptions", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CqlToElmInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_CodeFilterElementFormat extends scalaxb.ElemNameParser[CodeFilterElement] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CodeFilterElement")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CodeFilterElement] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "value")) ^^
      { case p1 ~ p2 ~ p3 =>
      CodeFilterElement(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@property").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@property" -> _ },
        (node \ "@valueSetProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@valueSetProperty" -> _ },
        (node \ "@search").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@search" -> _ },
        (node \ "@comparator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@comparator" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CodeFilterElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@property", _) => __obj.property foreach { x => attr = scala.xml.Attribute(null, "property", x.toString, attr) }
        case ("@valueSetProperty", _) => __obj.valueSetProperty foreach { x => attr = scala.xml.Attribute(null, "valueSetProperty", x.toString, attr) }
        case ("@search", _) => __obj.search foreach { x => attr = scala.xml.Attribute(null, "search", x.toString, attr) }
        case ("@comparator", _) => attr = scala.xml.Attribute(null, "comparator", __obj.comparator.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CodeFilterElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.value, Some("urn:hl7-org:elm:r1"), Some("value"), __scope, false))

  }

  trait Default_DateFilterElementFormat extends scalaxb.ElemNameParser[DateFilterElement] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("DateFilterElement")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[DateFilterElement] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "value")) ^^
      { case p1 ~ p2 ~ p3 =>
      DateFilterElement(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@property").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@property" -> _ },
        (node \ "@lowProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@lowProperty" -> _ },
        (node \ "@highProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@highProperty" -> _ },
        (node \ "@search").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@search" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: DateFilterElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@property", _) => __obj.property foreach { x => attr = scala.xml.Attribute(null, "property", x.toString, attr) }
        case ("@lowProperty", _) => __obj.lowProperty foreach { x => attr = scala.xml.Attribute(null, "lowProperty", x.toString, attr) }
        case ("@highProperty", _) => __obj.highProperty foreach { x => attr = scala.xml.Attribute(null, "highProperty", x.toString, attr) }
        case ("@search", _) => __obj.search foreach { x => attr = scala.xml.Attribute(null, "search", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: DateFilterElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.value, Some("urn:hl7-org:elm:r1"), Some("value"), __scope, false))

  }

  trait Default_OtherFilterElementFormat extends scalaxb.ElemNameParser[OtherFilterElement] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("OtherFilterElement")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[OtherFilterElement] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "value")) ^^
      { case p1 ~ p2 ~ p3 =>
      OtherFilterElement(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@property").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@property" -> _ },
        (node \ "@search").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@search" -> _ },
        (node \ "@comparator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@comparator" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: OtherFilterElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@property", _) => __obj.property foreach { x => attr = scala.xml.Attribute(null, "property", x.toString, attr) }
        case ("@search", _) => __obj.search foreach { x => attr = scala.xml.Attribute(null, "search", x.toString, attr) }
        case ("@comparator", _) => attr = scala.xml.Attribute(null, "comparator", __obj.comparator.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: OtherFilterElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.value, Some("urn:hl7-org:elm:r1"), Some("value"), __scope, false))

  }

  trait Default_IncludeElementFormat extends scalaxb.ElemNameParser[IncludeElement] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("IncludeElement")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IncludeElement] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      IncludeElement(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@includeFrom").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@includeFrom" -> _ },
        (node \ "@relatedDataType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@relatedDataType" -> _ },
        (node \ "@relatedProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@relatedProperty" -> _ },
        (node \ "@relatedSearch").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@relatedSearch" -> _ },
        (node \ "@isReverse").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@isReverse" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IncludeElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@includeFrom", _) => __obj.includeFrom foreach { x => attr = scala.xml.Attribute(null, "includeFrom", x.toString, attr) }
        case ("@relatedDataType", _) => attr = scala.xml.Attribute(null, "relatedDataType", scalaxb.Helper.toString(__obj.relatedDataType, __scope), attr)
        case ("@relatedProperty", _) => __obj.relatedProperty foreach { x => attr = scala.xml.Attribute(null, "relatedProperty", x.toString, attr) }
        case ("@relatedSearch", _) => __obj.relatedSearch foreach { x => attr = scala.xml.Attribute(null, "relatedSearch", x.toString, attr) }
        case ("@isReverse", _) => __obj.isReverse foreach { x => attr = scala.xml.Attribute(null, "isReverse", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IncludeElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_RetrieveFormat extends scalaxb.ElemNameParser[Retrieve] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Retrieve")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Retrieve] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "id")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codes")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "dateRange")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "context")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "include")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codeFilter")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "dateFilter")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "otherFilter")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 =>
      Retrieve(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p7 map { scalaxb.fromXML[IncludeElement](_, scalaxb.ElemName(node) :: stack) },
        p8 map { scalaxb.fromXML[CodeFilterElement](_, scalaxb.ElemName(node) :: stack) },
        p9 map { scalaxb.fromXML[DateFilterElement](_, scalaxb.ElemName(node) :: stack) },
        p10 map { scalaxb.fromXML[OtherFilterElement](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@dataType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@dataType" -> _ },
        (node \ "@templateId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@templateId" -> _ },
        (node \ "@idProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idProperty" -> _ },
        (node \ "@idSearch").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idSearch" -> _ },
        (node \ "@contextProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@contextProperty" -> _ },
        (node \ "@contextSearch").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@contextSearch" -> _ },
        (node \ "@codeProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@codeProperty" -> _ },
        (node \ "@codeSearch").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@codeSearch" -> _ },
        (node \ "@codeComparator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@codeComparator" -> _ },
        (node \ "@valueSetProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@valueSetProperty" -> _ },
        (node \ "@dateProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@dateProperty" -> _ },
        (node \ "@dateLowProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@dateLowProperty" -> _ },
        (node \ "@dateHighProperty").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@dateHighProperty" -> _ },
        (node \ "@dateSearch").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@dateSearch" -> _ },
        (node \ "@includedIn").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@includedIn" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Retrieve, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@dataType", _) => attr = scala.xml.Attribute(null, "dataType", scalaxb.Helper.toString(__obj.dataType, __scope), attr)
        case ("@templateId", _) => __obj.templateId foreach { x => attr = scala.xml.Attribute(null, "templateId", x.toString, attr) }
        case ("@idProperty", _) => __obj.idProperty foreach { x => attr = scala.xml.Attribute(null, "idProperty", x.toString, attr) }
        case ("@idSearch", _) => __obj.idSearch foreach { x => attr = scala.xml.Attribute(null, "idSearch", x.toString, attr) }
        case ("@contextProperty", _) => __obj.contextProperty foreach { x => attr = scala.xml.Attribute(null, "contextProperty", x.toString, attr) }
        case ("@contextSearch", _) => __obj.contextSearch foreach { x => attr = scala.xml.Attribute(null, "contextSearch", x.toString, attr) }
        case ("@codeProperty", _) => __obj.codeProperty foreach { x => attr = scala.xml.Attribute(null, "codeProperty", x.toString, attr) }
        case ("@codeSearch", _) => __obj.codeSearch foreach { x => attr = scala.xml.Attribute(null, "codeSearch", x.toString, attr) }
        case ("@codeComparator", _) => __obj.codeComparator foreach { x => attr = scala.xml.Attribute(null, "codeComparator", x.toString, attr) }
        case ("@valueSetProperty", _) => __obj.valueSetProperty foreach { x => attr = scala.xml.Attribute(null, "valueSetProperty", x.toString, attr) }
        case ("@dateProperty", _) => __obj.dateProperty foreach { x => attr = scala.xml.Attribute(null, "dateProperty", x.toString, attr) }
        case ("@dateLowProperty", _) => __obj.dateLowProperty foreach { x => attr = scala.xml.Attribute(null, "dateLowProperty", x.toString, attr) }
        case ("@dateHighProperty", _) => __obj.dateHighProperty foreach { x => attr = scala.xml.Attribute(null, "dateHighProperty", x.toString, attr) }
        case ("@dateSearch", _) => __obj.dateSearch foreach { x => attr = scala.xml.Attribute(null, "dateSearch", x.toString, attr) }
        case ("@includedIn", _) => __obj.includedIn foreach { x => attr = scala.xml.Attribute(null, "includedIn", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Retrieve, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.id map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("id"), __scope, false) } getOrElse {Nil},
        __obj.codes map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("codes"), __scope, false) } getOrElse {Nil},
        __obj.dateRange map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("dateRange"), __scope, false) } getOrElse {Nil},
        __obj.context map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("context"), __scope, false) } getOrElse {Nil},
        __obj.include flatMap { scalaxb.toXML[IncludeElement](_, Some("urn:hl7-org:elm:r1"), Some("include"), __scope, false) },
        __obj.codeFilter flatMap { scalaxb.toXML[CodeFilterElement](_, Some("urn:hl7-org:elm:r1"), Some("codeFilter"), __scope, false) },
        __obj.dateFilter flatMap { scalaxb.toXML[DateFilterElement](_, Some("urn:hl7-org:elm:r1"), Some("dateFilter"), __scope, false) },
        __obj.otherFilter flatMap { scalaxb.toXML[OtherFilterElement](_, Some("urn:hl7-org:elm:r1"), Some("otherFilter"), __scope, false) })

  }

  trait Default_SearchFormat extends scalaxb.ElemNameParser[Search] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Search")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Search] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 =>
      Search(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ },
        (node \ "@scope").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@scope" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Search, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => attr = scala.xml.Attribute(null, "path", __obj.path.toString, attr)
        case ("@scope", _) => __obj.scope foreach { x => attr = scala.xml.Attribute(null, "scope", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Search, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.source map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CodeSystemDefFormat extends scalaxb.ElemNameParser[CodeSystemDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CodeSystemDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CodeSystemDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      CodeSystemDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ },
        (node \ "@accessLevel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[AccessModifier](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[AccessModifier](scala.xml.Text("Public"), scalaxb.ElemName(node) :: stack))) map { "@accessLevel" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CodeSystemDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case ("@version", _) => __obj.version foreach { x => attr = scala.xml.Attribute(null, "version", x.toString, attr) }
        case ("@accessLevel", _) => if (__obj.accessLevel.toString != "Public") attr = scala.xml.Attribute(null, "accessLevel", __obj.accessLevel.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CodeSystemDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ValueSetDefFormat extends scalaxb.ElemNameParser[ValueSetDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ValueSetDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ValueSetDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codeSystem")) ^^
      { case p1 ~ p2 ~ p3 =>
      ValueSetDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[CodeSystemRef](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ },
        (node \ "@accessLevel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[AccessModifier](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[AccessModifier](scala.xml.Text("Public"), scalaxb.ElemName(node) :: stack))) map { "@accessLevel" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ValueSetDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case ("@version", _) => __obj.version foreach { x => attr = scala.xml.Attribute(null, "version", x.toString, attr) }
        case ("@accessLevel", _) => if (__obj.accessLevel.toString != "Public") attr = scala.xml.Attribute(null, "accessLevel", __obj.accessLevel.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ValueSetDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.codeSystem flatMap { scalaxb.toXML[CodeSystemRef](_, Some("urn:hl7-org:elm:r1"), Some("codeSystem"), __scope, false) })

  }

  trait Default_CodeDefFormat extends scalaxb.ElemNameParser[CodeDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CodeDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CodeDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codeSystem")) ^^
      { case p1 ~ p2 ~ p3 =>
      CodeDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[CodeSystemRef](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@display").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@display" -> _ },
        (node \ "@accessLevel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[AccessModifier](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[AccessModifier](scala.xml.Text("Public"), scalaxb.ElemName(node) :: stack))) map { "@accessLevel" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CodeDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case ("@display", _) => __obj.display foreach { x => attr = scala.xml.Attribute(null, "display", x.toString, attr) }
        case ("@accessLevel", _) => if (__obj.accessLevel.toString != "Public") attr = scala.xml.Attribute(null, "accessLevel", __obj.accessLevel.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CodeDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.codeSystem map { scalaxb.toXML[CodeSystemRef](_, Some("urn:hl7-org:elm:r1"), Some("codeSystem"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ConceptDefFormat extends scalaxb.ElemNameParser[ConceptDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConceptDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConceptDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "code")) ^^
      { case p1 ~ p2 ~ p3 =>
      ConceptDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[CodeRef](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@display").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@display" -> _ },
        (node \ "@accessLevel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[AccessModifier](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[AccessModifier](scala.xml.Text("Public"), scalaxb.ElemName(node) :: stack))) map { "@accessLevel" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConceptDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@display", _) => __obj.display foreach { x => attr = scala.xml.Attribute(null, "display", x.toString, attr) }
        case ("@accessLevel", _) => if (__obj.accessLevel.toString != "Public") attr = scala.xml.Attribute(null, "accessLevel", __obj.accessLevel.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConceptDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.code flatMap { scalaxb.toXML[CodeRef](_, Some("urn:hl7-org:elm:r1"), Some("code"), __scope, false) })

  }

  trait Default_CodeSystemRefFormat extends scalaxb.ElemNameParser[CodeSystemRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CodeSystemRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CodeSystemRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      CodeSystemRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@libraryName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CodeSystemRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@libraryName", _) => __obj.libraryName foreach { x => attr = scala.xml.Attribute(null, "libraryName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CodeSystemRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ValueSetRefFormat extends scalaxb.ElemNameParser[ValueSetRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ValueSetRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ValueSetRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ValueSetRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@libraryName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryName" -> _ },
        (node \ "@preserve").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@preserve" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ValueSetRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@libraryName", _) => __obj.libraryName foreach { x => attr = scala.xml.Attribute(null, "libraryName", x.toString, attr) }
        case ("@preserve", _) => __obj.preserve foreach { x => attr = scala.xml.Attribute(null, "preserve", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ValueSetRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CodeRefFormat extends scalaxb.ElemNameParser[CodeRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CodeRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CodeRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      CodeRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@libraryName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CodeRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@libraryName", _) => __obj.libraryName foreach { x => attr = scala.xml.Attribute(null, "libraryName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CodeRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ConceptRefFormat extends scalaxb.ElemNameParser[ConceptRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConceptRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConceptRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ConceptRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@libraryName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConceptRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@libraryName", _) => __obj.libraryName foreach { x => attr = scala.xml.Attribute(null, "libraryName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConceptRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CodeFormat extends scalaxb.ElemNameParser[Code] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Code")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Code] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "system")) ^^
      { case p1 ~ p2 ~ p3 =>
      Code(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[CodeSystemRef](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code" -> _ },
        (node \ "@display").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@display" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Code, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@code", _) => attr = scala.xml.Attribute(null, "code", __obj.code.toString, attr)
        case ("@display", _) => __obj.display foreach { x => attr = scala.xml.Attribute(null, "display", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Code, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[CodeSystemRef](__obj.system, Some("urn:hl7-org:elm:r1"), Some("system"), __scope, false))

  }

  trait Default_ConceptFormat extends scalaxb.ElemNameParser[Concept] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Concept")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Concept] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "code")) ^^
      { case p1 ~ p2 ~ p3 =>
      Concept(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[Code](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@display").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@display" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Concept, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@display", _) => __obj.display foreach { x => attr = scala.xml.Attribute(null, "display", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Concept, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.code flatMap { scalaxb.toXML[Code](_, Some("urn:hl7-org:elm:r1"), Some("code"), __scope, false) })

  }

  trait Default_InCodeSystemFormat extends scalaxb.ElemNameParser[InCodeSystem] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("InCodeSystem")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[InCodeSystem] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "code")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codesystem")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codesystemExpression")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      InCodeSystem(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[CodeSystemRef](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: InCodeSystem, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: InCodeSystem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.code, Some("urn:hl7-org:elm:r1"), Some("code"), __scope, false),
        __obj.codesystem map { scalaxb.toXML[CodeSystemRef](_, Some("urn:hl7-org:elm:r1"), Some("codesystem"), __scope, false) } getOrElse {Nil},
        __obj.codesystemExpression map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("codesystemExpression"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AnyInCodeSystemFormat extends scalaxb.ElemNameParser[AnyInCodeSystem] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("AnyInCodeSystem")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[AnyInCodeSystem] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codes")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codesystem")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codesystemExpression")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      AnyInCodeSystem(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[CodeSystemRef](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AnyInCodeSystem, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AnyInCodeSystem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.codes, Some("urn:hl7-org:elm:r1"), Some("codes"), __scope, false),
        __obj.codesystem map { scalaxb.toXML[CodeSystemRef](_, Some("urn:hl7-org:elm:r1"), Some("codesystem"), __scope, false) } getOrElse {Nil},
        __obj.codesystemExpression map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("codesystemExpression"), __scope, false) } getOrElse {Nil})

  }

  trait Default_InValueSetFormat extends scalaxb.ElemNameParser[InValueSet] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("InValueSet")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[InValueSet] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "code")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "valueset")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "valuesetExpression")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      InValueSet(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[ValueSetRef](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: InValueSet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: InValueSet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.code, Some("urn:hl7-org:elm:r1"), Some("code"), __scope, false),
        __obj.valueset map { scalaxb.toXML[ValueSetRef](_, Some("urn:hl7-org:elm:r1"), Some("valueset"), __scope, false) } getOrElse {Nil},
        __obj.valuesetExpression map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("valuesetExpression"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AnyInValueSetFormat extends scalaxb.ElemNameParser[AnyInValueSet] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("AnyInValueSet")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[AnyInValueSet] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "codes")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "valueset")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "valuesetExpression")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      AnyInValueSet(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[ValueSetRef](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AnyInValueSet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AnyInValueSet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.codes, Some("urn:hl7-org:elm:r1"), Some("codes"), __scope, false),
        __obj.valueset map { scalaxb.toXML[ValueSetRef](_, Some("urn:hl7-org:elm:r1"), Some("valueset"), __scope, false) } getOrElse {Nil},
        __obj.valuesetExpression map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("valuesetExpression"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ExpandValueSetFormat extends scalaxb.ElemNameParser[ExpandValueSet] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ExpandValueSet")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ExpandValueSet] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ExpandValueSet(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ExpandValueSet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ExpandValueSet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_SubsumesFormat extends scalaxb.ElemNameParser[Subsumes] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Subsumes")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Subsumes] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Subsumes(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Subsumes, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Subsumes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_SubsumedByFormat extends scalaxb.ElemNameParser[SubsumedBy] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("SubsumedBy")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SubsumedBy] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      SubsumedBy(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SubsumedBy, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SubsumedBy, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_QuantityFormat extends scalaxb.ElemNameParser[Quantity] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Quantity")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Quantity] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      Quantity(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ },
        (node \ "@unit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Quantity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.bigDecimal.toPlainString, attr) }
        case ("@unit", _) => __obj.unit foreach { x => attr = scala.xml.Attribute(null, "unit", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Quantity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_RatioFormat extends scalaxb.ElemNameParser[Ratio] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Ratio")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Ratio] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "numerator")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "denominator")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Ratio(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Quantity](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Quantity](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Ratio, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Ratio, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Quantity](__obj.numerator, Some("urn:hl7-org:elm:r1"), Some("numerator"), __scope, false),
        scalaxb.toXML[Quantity](__obj.denominator, Some("urn:hl7-org:elm:r1"), Some("denominator"), __scope, false))

  }

  trait Default_CalculateAgeFormat extends scalaxb.ElemNameParser[CalculateAge] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CalculateAge")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CalculateAge] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      CalculateAge(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CalculateAge, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CalculateAge, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_CalculateAgeAtFormat extends scalaxb.ElemNameParser[CalculateAgeAt] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CalculateAgeAt")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CalculateAgeAt] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      CalculateAgeAt(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CalculateAgeAt, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CalculateAgeAt, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ElementFormat extends scalaxb.XMLFormat[Element] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Element] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("ReturnClause")) => Right(scalaxb.fromXML[ReturnClause](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LetClause")) => Right(scalaxb.fromXML[LetClause](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Expression")) => Right(scalaxb.fromXML[Expression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("QueryLetRef")) => Right(scalaxb.fromXML[QueryLetRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Query")) => Right(scalaxb.fromXML[Query](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Property")) => Right(scalaxb.fromXML[Propertyable](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Search")) => Right(scalaxb.fromXML[Search](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Iteration")) => Right(scalaxb.fromXML[Iteration](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ForEach")) => Right(scalaxb.fromXML[ForEach](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MinValue")) => Right(scalaxb.fromXML[MinValue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Case")) => Right(scalaxb.fromXML[Case](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("If")) => Right(scalaxb.fromXML[If](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("List")) => Right(scalaxb.fromXML[ListType](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Instance")) => Right(scalaxb.fromXML[Instance](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Tuple")) => Right(scalaxb.fromXML[Tuple](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Literal")) => Right(scalaxb.fromXML[Literal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OperandRef")) => Right(scalaxb.fromXML[OperandRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ParameterRef")) => Right(scalaxb.fromXML[ParameterRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OperatorExpression")) => Right(scalaxb.fromXML[OperatorExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Descendents")) => Right(scalaxb.fromXML[Descendents](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Slice")) => Right(scalaxb.fromXML[Slice](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("First")) => Right(scalaxb.fromXML[First](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateTime")) => Right(scalaxb.fromXML[DateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Now")) => Right(scalaxb.fromXML[Now](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimeOfDay")) => Right(scalaxb.fromXML[TimeOfDay](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LastPositionOf")) => Right(scalaxb.fromXML[LastPositionOf](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SplitOnMatches")) => Right(scalaxb.fromXML[SplitOnMatches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Combine")) => Right(scalaxb.fromXML[Combine](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TernaryExpression")) => Right(scalaxb.fromXML[TernaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ReplaceMatches")) => Right(scalaxb.fromXML[ReplaceMatches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("UnaryExpression")) => Right(scalaxb.fromXML[UnaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SingletonFrom")) => Right(scalaxb.fromXML[SingletonFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Distinct")) => Right(scalaxb.fromXML[Distinct](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Flatten")) => Right(scalaxb.fromXML[Flatten](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Start")) => Right(scalaxb.fromXML[Start](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Width")) => Right(scalaxb.fromXML[Width](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimezoneOffsetFrom")) => Right(scalaxb.fromXML[TimezoneOffsetFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimeFrom")) => Right(scalaxb.fromXML[TimeFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Upper")) => Right(scalaxb.fromXML[Upper](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Precision")) => Right(scalaxb.fromXML[Precision](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Successor")) => Right(scalaxb.fromXML[Successor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ln")) => Right(scalaxb.fromXML[Ln](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Negate")) => Right(scalaxb.fromXML[Negate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Truncate")) => Right(scalaxb.fromXML[Truncate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ceiling")) => Right(scalaxb.fromXML[Ceiling](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToTime")) => Right(scalaxb.fromXML[ToTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToString")) => Right(scalaxb.fromXML[ToString](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToChars")) => Right(scalaxb.fromXML[ToChars](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToRatio")) => Right(scalaxb.fromXML[ToRatio](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToQuantity")) => Right(scalaxb.fromXML[ToQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToLong")) => Right(scalaxb.fromXML[ToLong](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToInteger")) => Right(scalaxb.fromXML[ToInteger](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDecimal")) => Right(scalaxb.fromXML[ToDecimal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDateTime")) => Right(scalaxb.fromXML[ToDateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDate")) => Right(scalaxb.fromXML[ToDate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToConcept")) => Right(scalaxb.fromXML[ToConcept](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToBoolean")) => Right(scalaxb.fromXML[ToBoolean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Convert")) => Right(scalaxb.fromXML[Convert](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Is")) => Right(scalaxb.fromXML[Is](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsFalse")) => Right(scalaxb.fromXML[IsFalse](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsNull")) => Right(scalaxb.fromXML[IsNull](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Not")) => Right(scalaxb.fromXML[Not](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsTrue")) => Right(scalaxb.fromXML[IsTrue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("As")) => Right(scalaxb.fromXML[As](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CanConvert")) => Right(scalaxb.fromXML[CanConvert](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToBoolean")) => Right(scalaxb.fromXML[ConvertsToBoolean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDate")) => Right(scalaxb.fromXML[ConvertsToDate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDateTime")) => Right(scalaxb.fromXML[ConvertsToDateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDecimal")) => Right(scalaxb.fromXML[ConvertsToDecimal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToInteger")) => Right(scalaxb.fromXML[ConvertsToInteger](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToLong")) => Right(scalaxb.fromXML[ConvertsToLong](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToQuantity")) => Right(scalaxb.fromXML[ConvertsToQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToRatio")) => Right(scalaxb.fromXML[ConvertsToRatio](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToList")) => Right(scalaxb.fromXML[ToList](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToString")) => Right(scalaxb.fromXML[ConvertsToString](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToTime")) => Right(scalaxb.fromXML[ConvertsToTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Floor")) => Right(scalaxb.fromXML[Floor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Abs")) => Right(scalaxb.fromXML[Abs](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Exp")) => Right(scalaxb.fromXML[Exp](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Predecessor")) => Right(scalaxb.fromXML[Predecessor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Length")) => Right(scalaxb.fromXML[Length](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Lower")) => Right(scalaxb.fromXML[Lower](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateFrom")) => Right(scalaxb.fromXML[DateFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimezoneFrom")) => Right(scalaxb.fromXML[TimezoneFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateTimeComponentFrom")) => Right(scalaxb.fromXML[DateTimeComponentFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PointFrom")) => Right(scalaxb.fromXML[PointFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Size")) => Right(scalaxb.fromXML[Size](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("End")) => Right(scalaxb.fromXML[End](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Exists")) => Right(scalaxb.fromXML[Exists](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CalculateAge")) => Right(scalaxb.fromXML[CalculateAge](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ExpandValueSet")) => Right(scalaxb.fromXML[ExpandValueSet](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("BinaryExpression")) => Right(scalaxb.fromXML[BinaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Times")) => Right(scalaxb.fromXML[Times](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Collapse")) => Right(scalaxb.fromXML[Collapse](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Starts")) => Right(scalaxb.fromXML[Starts](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OverlapsBefore")) => Right(scalaxb.fromXML[OverlapsBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MeetsAfter")) => Right(scalaxb.fromXML[MeetsAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Meets")) => Right(scalaxb.fromXML[Meets](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Before")) => Right(scalaxb.fromXML[Before](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIncludes")) => Right(scalaxb.fromXML[ProperIncludes](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Includes")) => Right(scalaxb.fromXML[IncludesType](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("In")) => Right(scalaxb.fromXML[In](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Contains")) => Right(scalaxb.fromXML[Contains](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameOrAfter")) => Right(scalaxb.fromXML[SameOrAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameAs")) => Right(scalaxb.fromXML[SameAs](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DifferenceBetween")) => Right(scalaxb.fromXML[DifferenceBetween](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Matches")) => Right(scalaxb.fromXML[Matches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("StartsWith")) => Right(scalaxb.fromXML[StartsWith](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Indexer")) => Right(scalaxb.fromXML[Indexer](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("HighBoundary")) => Right(scalaxb.fromXML[HighBoundary](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Log")) => Right(scalaxb.fromXML[Log](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TruncatedDivide")) => Right(scalaxb.fromXML[TruncatedDivide](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Multiply")) => Right(scalaxb.fromXML[Multiply](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Add")) => Right(scalaxb.fromXML[Add](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LessOrEqual")) => Right(scalaxb.fromXML[LessOrEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Less")) => Right(scalaxb.fromXML[Less](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Equivalent")) => Right(scalaxb.fromXML[Equivalent](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertQuantity")) => Right(scalaxb.fromXML[ConvertQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Implies")) => Right(scalaxb.fromXML[Implies](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Or")) => Right(scalaxb.fromXML[Or](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("And")) => Right(scalaxb.fromXML[And](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Xor")) => Right(scalaxb.fromXML[Xor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CanConvertQuantity")) => Right(scalaxb.fromXML[CanConvertQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Equal")) => Right(scalaxb.fromXML[Equal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("NotEqual")) => Right(scalaxb.fromXML[NotEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Greater")) => Right(scalaxb.fromXML[Greater](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("GreaterOrEqual")) => Right(scalaxb.fromXML[GreaterOrEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Subtract")) => Right(scalaxb.fromXML[Subtract](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Divide")) => Right(scalaxb.fromXML[Divide](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Modulo")) => Right(scalaxb.fromXML[Modulo](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Power")) => Right(scalaxb.fromXML[Power](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LowBoundary")) => Right(scalaxb.fromXML[LowBoundary](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("EndsWith")) => Right(scalaxb.fromXML[EndsWith](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DurationBetween")) => Right(scalaxb.fromXML[DurationBetween](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameOrBefore")) => Right(scalaxb.fromXML[SameOrBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperContains")) => Right(scalaxb.fromXML[ProperContains](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIn")) => Right(scalaxb.fromXML[ProperIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IncludedIn")) => Right(scalaxb.fromXML[IncludedIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIncludedIn")) => Right(scalaxb.fromXML[ProperIncludedIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("After")) => Right(scalaxb.fromXML[After](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MeetsBefore")) => Right(scalaxb.fromXML[MeetsBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Overlaps")) => Right(scalaxb.fromXML[Overlaps](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OverlapsAfter")) => Right(scalaxb.fromXML[OverlapsAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ends")) => Right(scalaxb.fromXML[Ends](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Expand")) => Right(scalaxb.fromXML[Expand](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Subsumes")) => Right(scalaxb.fromXML[Subsumes](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SubsumedBy")) => Right(scalaxb.fromXML[SubsumedBy](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CalculateAgeAt")) => Right(scalaxb.fromXML[CalculateAgeAt](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("NaryExpression")) => Right(scalaxb.fromXML[NaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Except")) => Right(scalaxb.fromXML[Except](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Union")) => Right(scalaxb.fromXML[Union](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Coalesce")) => Right(scalaxb.fromXML[Coalesce](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Concatenate")) => Right(scalaxb.fromXML[Concatenate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Intersect")) => Right(scalaxb.fromXML[Intersect](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Round")) => Right(scalaxb.fromXML[Round](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Split")) => Right(scalaxb.fromXML[Split](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PositionOf")) => Right(scalaxb.fromXML[PositionOf](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Substring")) => Right(scalaxb.fromXML[Substring](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Today")) => Right(scalaxb.fromXML[Today](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Date")) => Right(scalaxb.fromXML[Date](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Time")) => Right(scalaxb.fromXML[Time](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Last")) => Right(scalaxb.fromXML[Last](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IndexOf")) => Right(scalaxb.fromXML[IndexOf](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Children")) => Right(scalaxb.fromXML[Children](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Message")) => Right(scalaxb.fromXML[Message](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AnyInValueSet")) => Right(scalaxb.fromXML[AnyInValueSet](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AnyInCodeSystem")) => Right(scalaxb.fromXML[AnyInCodeSystem](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("InCodeSystem")) => Right(scalaxb.fromXML[InCodeSystem](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("InValueSet")) => Right(scalaxb.fromXML[InValueSet](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ExpressionRef")) => Right(scalaxb.fromXML[ExpressionRefable](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("FunctionRef")) => Right(scalaxb.fromXML[FunctionRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IdentifierRef")) => Right(scalaxb.fromXML[IdentifierRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Interval")) => Right(scalaxb.fromXML[Interval](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Null")) => Right(scalaxb.fromXML[Null](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MaxValue")) => Right(scalaxb.fromXML[MaxValue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Filter")) => Right(scalaxb.fromXML[Filter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Sort")) => Right(scalaxb.fromXML[Sort](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Repeat")) => Right(scalaxb.fromXML[Repeat](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Current")) => Right(scalaxb.fromXML[Current](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Total")) => Right(scalaxb.fromXML[Total](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AggregateExpression")) => Right(scalaxb.fromXML[AggregateExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AllTrue")) => Right(scalaxb.fromXML[AllTrue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("StdDev")) => Right(scalaxb.fromXML[StdDev](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Variance")) => Right(scalaxb.fromXML[Variance](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Median")) => Right(scalaxb.fromXML[Median](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Avg")) => Right(scalaxb.fromXML[Avg](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Min")) => Right(scalaxb.fromXML[Min](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Sum")) => Right(scalaxb.fromXML[Sum](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Aggregate")) => Right(scalaxb.fromXML[Aggregate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Count")) => Right(scalaxb.fromXML[Count](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Product")) => Right(scalaxb.fromXML[ProductType](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Max")) => Right(scalaxb.fromXML[Max](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("GeometricMean")) => Right(scalaxb.fromXML[GeometricMean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Mode")) => Right(scalaxb.fromXML[Mode](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PopulationVariance")) => Right(scalaxb.fromXML[PopulationVariance](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PopulationStdDev")) => Right(scalaxb.fromXML[PopulationStdDev](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AnyTrue")) => Right(scalaxb.fromXML[AnyTrue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AliasRef")) => Right(scalaxb.fromXML[AliasRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Quantity")) => Right(scalaxb.fromXML[Quantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Concept")) => Right(scalaxb.fromXML[Concept](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConceptRef")) => Right(scalaxb.fromXML[ConceptRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ValueSetRef")) => Right(scalaxb.fromXML[ValueSetRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Retrieve")) => Right(scalaxb.fromXML[Retrieve](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CodeSystemRef")) => Right(scalaxb.fromXML[CodeSystemRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CodeRef")) => Right(scalaxb.fromXML[CodeRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Code")) => Right(scalaxb.fromXML[Code](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ratio")) => Right(scalaxb.fromXML[Ratio](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TupleElementDefinition")) => Right(scalaxb.fromXML[TupleElementDefinition](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TypeSpecifier")) => Right(scalaxb.fromXML[TypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ChoiceTypeSpecifier")) => Right(scalaxb.fromXML[ChoiceTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IntervalTypeSpecifier")) => Right(scalaxb.fromXML[IntervalTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("NamedTypeSpecifier")) => Right(scalaxb.fromXML[NamedTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ListTypeSpecifier")) => Right(scalaxb.fromXML[ListTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TupleTypeSpecifier")) => Right(scalaxb.fromXML[TupleTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ParameterTypeSpecifier")) => Right(scalaxb.fromXML[ParameterTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ExpressionDef")) => Right(scalaxb.fromXML[ExpressionDefable](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("FunctionDef")) => Right(scalaxb.fromXML[FunctionDef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ParameterDef")) => Right(scalaxb.fromXML[ParameterDef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OperandDef")) => Right(scalaxb.fromXML[OperandDef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CaseItem")) => Right(scalaxb.fromXML[CaseItem](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AliasedQuerySource")) => Right(scalaxb.fromXML[AliasedQuerySourcable](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("RelationshipClause")) => Right(scalaxb.fromXML[RelationshipClause](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("With")) => Right(scalaxb.fromXML[With](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Without")) => Right(scalaxb.fromXML[Without](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SortByItem")) => Right(scalaxb.fromXML[SortByItem](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ByExpression")) => Right(scalaxb.fromXML[ByExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ByDirection")) => Right(scalaxb.fromXML[ByDirection](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ByColumn")) => Right(scalaxb.fromXML[ByColumn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SortClause")) => Right(scalaxb.fromXML[SortClause](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AggregateClause")) => Right(scalaxb.fromXML[AggregateClause](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ContextDef")) => Right(scalaxb.fromXML[ContextDef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("UsingDef")) => Right(scalaxb.fromXML[UsingDef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IncludeDef")) => Right(scalaxb.fromXML[IncludeDef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Library")) => Right(scalaxb.fromXML[Library](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConceptDef")) => Right(scalaxb.fromXML[ConceptDef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ValueSetDef")) => Right(scalaxb.fromXML[ValueSetDef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IncludeElement")) => Right(scalaxb.fromXML[IncludeElement](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateFilterElement")) => Right(scalaxb.fromXML[DateFilterElement](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CodeFilterElement")) => Right(scalaxb.fromXML[CodeFilterElement](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OtherFilterElement")) => Right(scalaxb.fromXML[OtherFilterElement](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CodeSystemDef")) => Right(scalaxb.fromXML[CodeSystemDef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CodeDef")) => Right(scalaxb.fromXML[CodeDef](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: Element, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: ReturnClause => scalaxb.toXML[ReturnClause](x, __namespace, __elementLabel, __scope, true)
      case x: LetClause => scalaxb.toXML[LetClause](x, __namespace, __elementLabel, __scope, true)
      case x: Expression => scalaxb.toXML[Expression](x, __namespace, __elementLabel, __scope, true)
      case x: TupleElementDefinition => scalaxb.toXML[TupleElementDefinition](x, __namespace, __elementLabel, __scope, true)
      case x: TypeSpecifier => scalaxb.toXML[TypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: ExpressionDefable => scalaxb.toXML[ExpressionDefable](x, __namespace, __elementLabel, __scope, true)
      case x: ParameterDef => scalaxb.toXML[ParameterDef](x, __namespace, __elementLabel, __scope, true)
      case x: OperandDef => scalaxb.toXML[OperandDef](x, __namespace, __elementLabel, __scope, true)
      case x: CaseItem => scalaxb.toXML[CaseItem](x, __namespace, __elementLabel, __scope, true)
      case x: AliasedQuerySourcable => scalaxb.toXML[AliasedQuerySourcable](x, __namespace, __elementLabel, __scope, true)
      case x: SortByItem => scalaxb.toXML[SortByItem](x, __namespace, __elementLabel, __scope, true)
      case x: SortClause => scalaxb.toXML[SortClause](x, __namespace, __elementLabel, __scope, true)
      case x: AggregateClause => scalaxb.toXML[AggregateClause](x, __namespace, __elementLabel, __scope, true)
      case x: ContextDef => scalaxb.toXML[ContextDef](x, __namespace, __elementLabel, __scope, true)
      case x: UsingDef => scalaxb.toXML[UsingDef](x, __namespace, __elementLabel, __scope, true)
      case x: IncludeDef => scalaxb.toXML[IncludeDef](x, __namespace, __elementLabel, __scope, true)
      case x: Library => scalaxb.toXML[Library](x, __namespace, __elementLabel, __scope, true)
      case x: ConceptDef => scalaxb.toXML[ConceptDef](x, __namespace, __elementLabel, __scope, true)
      case x: ValueSetDef => scalaxb.toXML[ValueSetDef](x, __namespace, __elementLabel, __scope, true)
      case x: IncludeElement => scalaxb.toXML[IncludeElement](x, __namespace, __elementLabel, __scope, true)
      case x: DateFilterElement => scalaxb.toXML[DateFilterElement](x, __namespace, __elementLabel, __scope, true)
      case x: CodeFilterElement => scalaxb.toXML[CodeFilterElement](x, __namespace, __elementLabel, __scope, true)
      case x: OtherFilterElement => scalaxb.toXML[OtherFilterElement](x, __namespace, __elementLabel, __scope, true)
      case x: CodeSystemDef => scalaxb.toXML[CodeSystemDef](x, __namespace, __elementLabel, __scope, true)
      case x: CodeDef => scalaxb.toXML[CodeDef](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_TypeSpecifierFormat extends scalaxb.XMLFormat[TypeSpecifier] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, TypeSpecifier] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("ChoiceTypeSpecifier")) => Right(scalaxb.fromXML[ChoiceTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IntervalTypeSpecifier")) => Right(scalaxb.fromXML[IntervalTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("NamedTypeSpecifier")) => Right(scalaxb.fromXML[NamedTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ListTypeSpecifier")) => Right(scalaxb.fromXML[ListTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TupleTypeSpecifier")) => Right(scalaxb.fromXML[TupleTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ParameterTypeSpecifier")) => Right(scalaxb.fromXML[ParameterTypeSpecifier](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: TypeSpecifier, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: ChoiceTypeSpecifier => scalaxb.toXML[ChoiceTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: IntervalTypeSpecifier => scalaxb.toXML[IntervalTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: NamedTypeSpecifier => scalaxb.toXML[NamedTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: ListTypeSpecifier => scalaxb.toXML[ListTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: TupleTypeSpecifier => scalaxb.toXML[TupleTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: ParameterTypeSpecifier => scalaxb.toXML[ParameterTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_NamedTypeSpecifierFormat extends scalaxb.ElemNameParser[NamedTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("NamedTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[NamedTypeSpecifier] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      NamedTypeSpecifier(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: NamedTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", scalaxb.Helper.toString(__obj.name, __scope), attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: NamedTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_IntervalTypeSpecifierFormat extends scalaxb.ElemNameParser[IntervalTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("IntervalTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IntervalTypeSpecifier] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "pointType")) ^^
      { case p1 ~ p2 ~ p3 =>
      IntervalTypeSpecifier(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[TypeSpecifier](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IntervalTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IntervalTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[TypeSpecifier](__obj.pointType, Some("urn:hl7-org:elm:r1"), Some("pointType"), __scope, false))

  }

  trait Default_ListTypeSpecifierFormat extends scalaxb.ElemNameParser[ListTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ListTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ListTypeSpecifier] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "elementType")) ^^
      { case p1 ~ p2 ~ p3 =>
      ListTypeSpecifier(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[TypeSpecifier](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ListTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ListTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[TypeSpecifier](__obj.elementType, Some("urn:hl7-org:elm:r1"), Some("elementType"), __scope, false))

  }

  trait Default_TupleElementDefinitionFormat extends scalaxb.ElemNameParser[TupleElementDefinition] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("TupleElementDefinition")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TupleElementDefinition] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "type")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "elementType")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      TupleElementDefinition(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TupleElementDefinition, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TupleElementDefinition, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.typeValue map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("type"), __scope, false) } getOrElse {Nil},
        __obj.elementType map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("elementType"), __scope, false) } getOrElse {Nil})

  }

  trait Default_TupleTypeSpecifierFormat extends scalaxb.ElemNameParser[TupleTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("TupleTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TupleTypeSpecifier] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "element")) ^^
      { case p1 ~ p2 ~ p3 =>
      TupleTypeSpecifier(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TupleElementDefinition](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TupleTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TupleTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.element flatMap { scalaxb.toXML[TupleElementDefinition](_, Some("urn:hl7-org:elm:r1"), Some("element"), __scope, false) })

  }

  trait Default_ChoiceTypeSpecifierFormat extends scalaxb.ElemNameParser[ChoiceTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ChoiceTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ChoiceTypeSpecifier] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "type")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "choice")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ChoiceTypeSpecifier(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ChoiceTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ChoiceTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.typeValue flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("type"), __scope, false) },
        __obj.choice flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("choice"), __scope, false) })

  }

  trait Default_ParameterTypeSpecifierFormat extends scalaxb.ElemNameParser[ParameterTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ParameterTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ParameterTypeSpecifier] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ParameterTypeSpecifier(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@parameterName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@parameterName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ParameterTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@parameterName", _) => attr = scala.xml.Attribute(null, "parameterName", __obj.parameterName.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ParameterTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ExpressionFormat extends scalaxb.XMLFormat[Expression] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Expression] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("QueryLetRef")) => Right(scalaxb.fromXML[QueryLetRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Query")) => Right(scalaxb.fromXML[Query](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Property")) => Right(scalaxb.fromXML[Propertyable](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Search")) => Right(scalaxb.fromXML[Search](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Iteration")) => Right(scalaxb.fromXML[Iteration](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ForEach")) => Right(scalaxb.fromXML[ForEach](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MinValue")) => Right(scalaxb.fromXML[MinValue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Case")) => Right(scalaxb.fromXML[Case](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("If")) => Right(scalaxb.fromXML[If](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("List")) => Right(scalaxb.fromXML[ListType](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Instance")) => Right(scalaxb.fromXML[Instance](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Tuple")) => Right(scalaxb.fromXML[Tuple](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Literal")) => Right(scalaxb.fromXML[Literal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OperandRef")) => Right(scalaxb.fromXML[OperandRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ParameterRef")) => Right(scalaxb.fromXML[ParameterRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OperatorExpression")) => Right(scalaxb.fromXML[OperatorExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Descendents")) => Right(scalaxb.fromXML[Descendents](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Slice")) => Right(scalaxb.fromXML[Slice](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("First")) => Right(scalaxb.fromXML[First](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateTime")) => Right(scalaxb.fromXML[DateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Now")) => Right(scalaxb.fromXML[Now](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimeOfDay")) => Right(scalaxb.fromXML[TimeOfDay](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LastPositionOf")) => Right(scalaxb.fromXML[LastPositionOf](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SplitOnMatches")) => Right(scalaxb.fromXML[SplitOnMatches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Combine")) => Right(scalaxb.fromXML[Combine](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TernaryExpression")) => Right(scalaxb.fromXML[TernaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ReplaceMatches")) => Right(scalaxb.fromXML[ReplaceMatches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("UnaryExpression")) => Right(scalaxb.fromXML[UnaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SingletonFrom")) => Right(scalaxb.fromXML[SingletonFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Distinct")) => Right(scalaxb.fromXML[Distinct](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Flatten")) => Right(scalaxb.fromXML[Flatten](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Start")) => Right(scalaxb.fromXML[Start](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Width")) => Right(scalaxb.fromXML[Width](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimezoneOffsetFrom")) => Right(scalaxb.fromXML[TimezoneOffsetFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimeFrom")) => Right(scalaxb.fromXML[TimeFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Upper")) => Right(scalaxb.fromXML[Upper](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Precision")) => Right(scalaxb.fromXML[Precision](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Successor")) => Right(scalaxb.fromXML[Successor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ln")) => Right(scalaxb.fromXML[Ln](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Negate")) => Right(scalaxb.fromXML[Negate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Truncate")) => Right(scalaxb.fromXML[Truncate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ceiling")) => Right(scalaxb.fromXML[Ceiling](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToTime")) => Right(scalaxb.fromXML[ToTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToString")) => Right(scalaxb.fromXML[ToString](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToChars")) => Right(scalaxb.fromXML[ToChars](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToRatio")) => Right(scalaxb.fromXML[ToRatio](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToQuantity")) => Right(scalaxb.fromXML[ToQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToLong")) => Right(scalaxb.fromXML[ToLong](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToInteger")) => Right(scalaxb.fromXML[ToInteger](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDecimal")) => Right(scalaxb.fromXML[ToDecimal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDateTime")) => Right(scalaxb.fromXML[ToDateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDate")) => Right(scalaxb.fromXML[ToDate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToConcept")) => Right(scalaxb.fromXML[ToConcept](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToBoolean")) => Right(scalaxb.fromXML[ToBoolean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Convert")) => Right(scalaxb.fromXML[Convert](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Is")) => Right(scalaxb.fromXML[Is](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsFalse")) => Right(scalaxb.fromXML[IsFalse](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsNull")) => Right(scalaxb.fromXML[IsNull](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Not")) => Right(scalaxb.fromXML[Not](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsTrue")) => Right(scalaxb.fromXML[IsTrue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("As")) => Right(scalaxb.fromXML[As](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CanConvert")) => Right(scalaxb.fromXML[CanConvert](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToBoolean")) => Right(scalaxb.fromXML[ConvertsToBoolean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDate")) => Right(scalaxb.fromXML[ConvertsToDate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDateTime")) => Right(scalaxb.fromXML[ConvertsToDateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDecimal")) => Right(scalaxb.fromXML[ConvertsToDecimal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToInteger")) => Right(scalaxb.fromXML[ConvertsToInteger](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToLong")) => Right(scalaxb.fromXML[ConvertsToLong](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToQuantity")) => Right(scalaxb.fromXML[ConvertsToQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToRatio")) => Right(scalaxb.fromXML[ConvertsToRatio](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToList")) => Right(scalaxb.fromXML[ToList](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToString")) => Right(scalaxb.fromXML[ConvertsToString](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToTime")) => Right(scalaxb.fromXML[ConvertsToTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Floor")) => Right(scalaxb.fromXML[Floor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Abs")) => Right(scalaxb.fromXML[Abs](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Exp")) => Right(scalaxb.fromXML[Exp](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Predecessor")) => Right(scalaxb.fromXML[Predecessor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Length")) => Right(scalaxb.fromXML[Length](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Lower")) => Right(scalaxb.fromXML[Lower](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateFrom")) => Right(scalaxb.fromXML[DateFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimezoneFrom")) => Right(scalaxb.fromXML[TimezoneFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateTimeComponentFrom")) => Right(scalaxb.fromXML[DateTimeComponentFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PointFrom")) => Right(scalaxb.fromXML[PointFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Size")) => Right(scalaxb.fromXML[Size](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("End")) => Right(scalaxb.fromXML[End](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Exists")) => Right(scalaxb.fromXML[Exists](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CalculateAge")) => Right(scalaxb.fromXML[CalculateAge](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ExpandValueSet")) => Right(scalaxb.fromXML[ExpandValueSet](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("BinaryExpression")) => Right(scalaxb.fromXML[BinaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Times")) => Right(scalaxb.fromXML[Times](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Collapse")) => Right(scalaxb.fromXML[Collapse](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Starts")) => Right(scalaxb.fromXML[Starts](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OverlapsBefore")) => Right(scalaxb.fromXML[OverlapsBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MeetsAfter")) => Right(scalaxb.fromXML[MeetsAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Meets")) => Right(scalaxb.fromXML[Meets](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Before")) => Right(scalaxb.fromXML[Before](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIncludes")) => Right(scalaxb.fromXML[ProperIncludes](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Includes")) => Right(scalaxb.fromXML[IncludesType](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("In")) => Right(scalaxb.fromXML[In](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Contains")) => Right(scalaxb.fromXML[Contains](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameOrAfter")) => Right(scalaxb.fromXML[SameOrAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameAs")) => Right(scalaxb.fromXML[SameAs](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DifferenceBetween")) => Right(scalaxb.fromXML[DifferenceBetween](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Matches")) => Right(scalaxb.fromXML[Matches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("StartsWith")) => Right(scalaxb.fromXML[StartsWith](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Indexer")) => Right(scalaxb.fromXML[Indexer](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("HighBoundary")) => Right(scalaxb.fromXML[HighBoundary](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Log")) => Right(scalaxb.fromXML[Log](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TruncatedDivide")) => Right(scalaxb.fromXML[TruncatedDivide](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Multiply")) => Right(scalaxb.fromXML[Multiply](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Add")) => Right(scalaxb.fromXML[Add](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LessOrEqual")) => Right(scalaxb.fromXML[LessOrEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Less")) => Right(scalaxb.fromXML[Less](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Equivalent")) => Right(scalaxb.fromXML[Equivalent](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertQuantity")) => Right(scalaxb.fromXML[ConvertQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Implies")) => Right(scalaxb.fromXML[Implies](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Or")) => Right(scalaxb.fromXML[Or](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("And")) => Right(scalaxb.fromXML[And](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Xor")) => Right(scalaxb.fromXML[Xor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CanConvertQuantity")) => Right(scalaxb.fromXML[CanConvertQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Equal")) => Right(scalaxb.fromXML[Equal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("NotEqual")) => Right(scalaxb.fromXML[NotEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Greater")) => Right(scalaxb.fromXML[Greater](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("GreaterOrEqual")) => Right(scalaxb.fromXML[GreaterOrEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Subtract")) => Right(scalaxb.fromXML[Subtract](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Divide")) => Right(scalaxb.fromXML[Divide](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Modulo")) => Right(scalaxb.fromXML[Modulo](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Power")) => Right(scalaxb.fromXML[Power](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LowBoundary")) => Right(scalaxb.fromXML[LowBoundary](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("EndsWith")) => Right(scalaxb.fromXML[EndsWith](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DurationBetween")) => Right(scalaxb.fromXML[DurationBetween](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameOrBefore")) => Right(scalaxb.fromXML[SameOrBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperContains")) => Right(scalaxb.fromXML[ProperContains](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIn")) => Right(scalaxb.fromXML[ProperIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IncludedIn")) => Right(scalaxb.fromXML[IncludedIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIncludedIn")) => Right(scalaxb.fromXML[ProperIncludedIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("After")) => Right(scalaxb.fromXML[After](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MeetsBefore")) => Right(scalaxb.fromXML[MeetsBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Overlaps")) => Right(scalaxb.fromXML[Overlaps](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OverlapsAfter")) => Right(scalaxb.fromXML[OverlapsAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ends")) => Right(scalaxb.fromXML[Ends](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Expand")) => Right(scalaxb.fromXML[Expand](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Subsumes")) => Right(scalaxb.fromXML[Subsumes](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SubsumedBy")) => Right(scalaxb.fromXML[SubsumedBy](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CalculateAgeAt")) => Right(scalaxb.fromXML[CalculateAgeAt](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("NaryExpression")) => Right(scalaxb.fromXML[NaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Except")) => Right(scalaxb.fromXML[Except](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Union")) => Right(scalaxb.fromXML[Union](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Coalesce")) => Right(scalaxb.fromXML[Coalesce](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Concatenate")) => Right(scalaxb.fromXML[Concatenate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Intersect")) => Right(scalaxb.fromXML[Intersect](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Round")) => Right(scalaxb.fromXML[Round](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Split")) => Right(scalaxb.fromXML[Split](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PositionOf")) => Right(scalaxb.fromXML[PositionOf](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Substring")) => Right(scalaxb.fromXML[Substring](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Today")) => Right(scalaxb.fromXML[Today](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Date")) => Right(scalaxb.fromXML[Date](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Time")) => Right(scalaxb.fromXML[Time](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Last")) => Right(scalaxb.fromXML[Last](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IndexOf")) => Right(scalaxb.fromXML[IndexOf](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Children")) => Right(scalaxb.fromXML[Children](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Message")) => Right(scalaxb.fromXML[Message](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AnyInValueSet")) => Right(scalaxb.fromXML[AnyInValueSet](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AnyInCodeSystem")) => Right(scalaxb.fromXML[AnyInCodeSystem](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("InCodeSystem")) => Right(scalaxb.fromXML[InCodeSystem](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("InValueSet")) => Right(scalaxb.fromXML[InValueSet](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ExpressionRef")) => Right(scalaxb.fromXML[ExpressionRefable](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("FunctionRef")) => Right(scalaxb.fromXML[FunctionRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IdentifierRef")) => Right(scalaxb.fromXML[IdentifierRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Interval")) => Right(scalaxb.fromXML[Interval](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Null")) => Right(scalaxb.fromXML[Null](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MaxValue")) => Right(scalaxb.fromXML[MaxValue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Filter")) => Right(scalaxb.fromXML[Filter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Sort")) => Right(scalaxb.fromXML[Sort](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Repeat")) => Right(scalaxb.fromXML[Repeat](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Current")) => Right(scalaxb.fromXML[Current](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Total")) => Right(scalaxb.fromXML[Total](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AggregateExpression")) => Right(scalaxb.fromXML[AggregateExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AllTrue")) => Right(scalaxb.fromXML[AllTrue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("StdDev")) => Right(scalaxb.fromXML[StdDev](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Variance")) => Right(scalaxb.fromXML[Variance](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Median")) => Right(scalaxb.fromXML[Median](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Avg")) => Right(scalaxb.fromXML[Avg](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Min")) => Right(scalaxb.fromXML[Min](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Sum")) => Right(scalaxb.fromXML[Sum](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Aggregate")) => Right(scalaxb.fromXML[Aggregate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Count")) => Right(scalaxb.fromXML[Count](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Product")) => Right(scalaxb.fromXML[ProductType](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Max")) => Right(scalaxb.fromXML[Max](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("GeometricMean")) => Right(scalaxb.fromXML[GeometricMean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Mode")) => Right(scalaxb.fromXML[Mode](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PopulationVariance")) => Right(scalaxb.fromXML[PopulationVariance](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PopulationStdDev")) => Right(scalaxb.fromXML[PopulationStdDev](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AnyTrue")) => Right(scalaxb.fromXML[AnyTrue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AliasRef")) => Right(scalaxb.fromXML[AliasRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Quantity")) => Right(scalaxb.fromXML[Quantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Concept")) => Right(scalaxb.fromXML[Concept](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConceptRef")) => Right(scalaxb.fromXML[ConceptRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ValueSetRef")) => Right(scalaxb.fromXML[ValueSetRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Retrieve")) => Right(scalaxb.fromXML[Retrieve](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CodeSystemRef")) => Right(scalaxb.fromXML[CodeSystemRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CodeRef")) => Right(scalaxb.fromXML[CodeRef](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Code")) => Right(scalaxb.fromXML[Code](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ratio")) => Right(scalaxb.fromXML[Ratio](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: Expression, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: QueryLetRef => scalaxb.toXML[QueryLetRef](x, __namespace, __elementLabel, __scope, true)
      case x: Query => scalaxb.toXML[Query](x, __namespace, __elementLabel, __scope, true)
      case x: Propertyable => scalaxb.toXML[Propertyable](x, __namespace, __elementLabel, __scope, true)
      case x: Iteration => scalaxb.toXML[Iteration](x, __namespace, __elementLabel, __scope, true)
      case x: ForEach => scalaxb.toXML[ForEach](x, __namespace, __elementLabel, __scope, true)
      case x: MinValue => scalaxb.toXML[MinValue](x, __namespace, __elementLabel, __scope, true)
      case x: Case => scalaxb.toXML[Case](x, __namespace, __elementLabel, __scope, true)
      case x: If => scalaxb.toXML[If](x, __namespace, __elementLabel, __scope, true)
      case x: ListType => scalaxb.toXML[ListType](x, __namespace, __elementLabel, __scope, true)
      case x: Instance => scalaxb.toXML[Instance](x, __namespace, __elementLabel, __scope, true)
      case x: Tuple => scalaxb.toXML[Tuple](x, __namespace, __elementLabel, __scope, true)
      case x: Literal => scalaxb.toXML[Literal](x, __namespace, __elementLabel, __scope, true)
      case x: OperandRef => scalaxb.toXML[OperandRef](x, __namespace, __elementLabel, __scope, true)
      case x: ParameterRef => scalaxb.toXML[ParameterRef](x, __namespace, __elementLabel, __scope, true)
      case x: OperatorExpression => scalaxb.toXML[OperatorExpression](x, __namespace, __elementLabel, __scope, true)
      case x: ExpressionRefable => scalaxb.toXML[ExpressionRefable](x, __namespace, __elementLabel, __scope, true)
      case x: IdentifierRef => scalaxb.toXML[IdentifierRef](x, __namespace, __elementLabel, __scope, true)
      case x: Interval => scalaxb.toXML[Interval](x, __namespace, __elementLabel, __scope, true)
      case x: Null => scalaxb.toXML[Null](x, __namespace, __elementLabel, __scope, true)
      case x: MaxValue => scalaxb.toXML[MaxValue](x, __namespace, __elementLabel, __scope, true)
      case x: Filter => scalaxb.toXML[Filter](x, __namespace, __elementLabel, __scope, true)
      case x: Sort => scalaxb.toXML[Sort](x, __namespace, __elementLabel, __scope, true)
      case x: Repeat => scalaxb.toXML[Repeat](x, __namespace, __elementLabel, __scope, true)
      case x: Current => scalaxb.toXML[Current](x, __namespace, __elementLabel, __scope, true)
      case x: Total => scalaxb.toXML[Total](x, __namespace, __elementLabel, __scope, true)
      case x: AggregateExpression => scalaxb.toXML[AggregateExpression](x, __namespace, __elementLabel, __scope, true)
      case x: AliasRef => scalaxb.toXML[AliasRef](x, __namespace, __elementLabel, __scope, true)
      case x: Quantity => scalaxb.toXML[Quantity](x, __namespace, __elementLabel, __scope, true)
      case x: Concept => scalaxb.toXML[Concept](x, __namespace, __elementLabel, __scope, true)
      case x: ConceptRef => scalaxb.toXML[ConceptRef](x, __namespace, __elementLabel, __scope, true)
      case x: ValueSetRef => scalaxb.toXML[ValueSetRef](x, __namespace, __elementLabel, __scope, true)
      case x: Retrieve => scalaxb.toXML[Retrieve](x, __namespace, __elementLabel, __scope, true)
      case x: CodeSystemRef => scalaxb.toXML[CodeSystemRef](x, __namespace, __elementLabel, __scope, true)
      case x: CodeRef => scalaxb.toXML[CodeRef](x, __namespace, __elementLabel, __scope, true)
      case x: Code => scalaxb.toXML[Code](x, __namespace, __elementLabel, __scope, true)
      case x: Ratio => scalaxb.toXML[Ratio](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_OperatorExpressionFormat extends scalaxb.XMLFormat[OperatorExpression] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, OperatorExpression] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("Descendents")) => Right(scalaxb.fromXML[Descendents](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Slice")) => Right(scalaxb.fromXML[Slice](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("First")) => Right(scalaxb.fromXML[First](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateTime")) => Right(scalaxb.fromXML[DateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Now")) => Right(scalaxb.fromXML[Now](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimeOfDay")) => Right(scalaxb.fromXML[TimeOfDay](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LastPositionOf")) => Right(scalaxb.fromXML[LastPositionOf](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SplitOnMatches")) => Right(scalaxb.fromXML[SplitOnMatches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Combine")) => Right(scalaxb.fromXML[Combine](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TernaryExpression")) => Right(scalaxb.fromXML[TernaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ReplaceMatches")) => Right(scalaxb.fromXML[ReplaceMatches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("UnaryExpression")) => Right(scalaxb.fromXML[UnaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SingletonFrom")) => Right(scalaxb.fromXML[SingletonFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Distinct")) => Right(scalaxb.fromXML[Distinct](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Flatten")) => Right(scalaxb.fromXML[Flatten](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Start")) => Right(scalaxb.fromXML[Start](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Width")) => Right(scalaxb.fromXML[Width](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimezoneOffsetFrom")) => Right(scalaxb.fromXML[TimezoneOffsetFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimeFrom")) => Right(scalaxb.fromXML[TimeFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Upper")) => Right(scalaxb.fromXML[Upper](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Precision")) => Right(scalaxb.fromXML[Precision](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Successor")) => Right(scalaxb.fromXML[Successor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ln")) => Right(scalaxb.fromXML[Ln](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Negate")) => Right(scalaxb.fromXML[Negate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Truncate")) => Right(scalaxb.fromXML[Truncate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ceiling")) => Right(scalaxb.fromXML[Ceiling](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToTime")) => Right(scalaxb.fromXML[ToTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToString")) => Right(scalaxb.fromXML[ToString](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToChars")) => Right(scalaxb.fromXML[ToChars](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToRatio")) => Right(scalaxb.fromXML[ToRatio](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToQuantity")) => Right(scalaxb.fromXML[ToQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToLong")) => Right(scalaxb.fromXML[ToLong](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToInteger")) => Right(scalaxb.fromXML[ToInteger](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDecimal")) => Right(scalaxb.fromXML[ToDecimal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDateTime")) => Right(scalaxb.fromXML[ToDateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDate")) => Right(scalaxb.fromXML[ToDate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToConcept")) => Right(scalaxb.fromXML[ToConcept](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToBoolean")) => Right(scalaxb.fromXML[ToBoolean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Convert")) => Right(scalaxb.fromXML[Convert](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Is")) => Right(scalaxb.fromXML[Is](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsFalse")) => Right(scalaxb.fromXML[IsFalse](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsNull")) => Right(scalaxb.fromXML[IsNull](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Not")) => Right(scalaxb.fromXML[Not](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsTrue")) => Right(scalaxb.fromXML[IsTrue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("As")) => Right(scalaxb.fromXML[As](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CanConvert")) => Right(scalaxb.fromXML[CanConvert](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToBoolean")) => Right(scalaxb.fromXML[ConvertsToBoolean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDate")) => Right(scalaxb.fromXML[ConvertsToDate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDateTime")) => Right(scalaxb.fromXML[ConvertsToDateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDecimal")) => Right(scalaxb.fromXML[ConvertsToDecimal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToInteger")) => Right(scalaxb.fromXML[ConvertsToInteger](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToLong")) => Right(scalaxb.fromXML[ConvertsToLong](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToQuantity")) => Right(scalaxb.fromXML[ConvertsToQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToRatio")) => Right(scalaxb.fromXML[ConvertsToRatio](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToList")) => Right(scalaxb.fromXML[ToList](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToString")) => Right(scalaxb.fromXML[ConvertsToString](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToTime")) => Right(scalaxb.fromXML[ConvertsToTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Floor")) => Right(scalaxb.fromXML[Floor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Abs")) => Right(scalaxb.fromXML[Abs](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Exp")) => Right(scalaxb.fromXML[Exp](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Predecessor")) => Right(scalaxb.fromXML[Predecessor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Length")) => Right(scalaxb.fromXML[Length](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Lower")) => Right(scalaxb.fromXML[Lower](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateFrom")) => Right(scalaxb.fromXML[DateFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimezoneFrom")) => Right(scalaxb.fromXML[TimezoneFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateTimeComponentFrom")) => Right(scalaxb.fromXML[DateTimeComponentFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PointFrom")) => Right(scalaxb.fromXML[PointFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Size")) => Right(scalaxb.fromXML[Size](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("End")) => Right(scalaxb.fromXML[End](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Exists")) => Right(scalaxb.fromXML[Exists](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CalculateAge")) => Right(scalaxb.fromXML[CalculateAge](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ExpandValueSet")) => Right(scalaxb.fromXML[ExpandValueSet](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("BinaryExpression")) => Right(scalaxb.fromXML[BinaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Times")) => Right(scalaxb.fromXML[Times](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Collapse")) => Right(scalaxb.fromXML[Collapse](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Starts")) => Right(scalaxb.fromXML[Starts](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OverlapsBefore")) => Right(scalaxb.fromXML[OverlapsBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MeetsAfter")) => Right(scalaxb.fromXML[MeetsAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Meets")) => Right(scalaxb.fromXML[Meets](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Before")) => Right(scalaxb.fromXML[Before](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIncludes")) => Right(scalaxb.fromXML[ProperIncludes](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Includes")) => Right(scalaxb.fromXML[IncludesType](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("In")) => Right(scalaxb.fromXML[In](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Contains")) => Right(scalaxb.fromXML[Contains](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameOrAfter")) => Right(scalaxb.fromXML[SameOrAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameAs")) => Right(scalaxb.fromXML[SameAs](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DifferenceBetween")) => Right(scalaxb.fromXML[DifferenceBetween](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Matches")) => Right(scalaxb.fromXML[Matches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("StartsWith")) => Right(scalaxb.fromXML[StartsWith](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Indexer")) => Right(scalaxb.fromXML[Indexer](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("HighBoundary")) => Right(scalaxb.fromXML[HighBoundary](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Log")) => Right(scalaxb.fromXML[Log](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TruncatedDivide")) => Right(scalaxb.fromXML[TruncatedDivide](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Multiply")) => Right(scalaxb.fromXML[Multiply](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Add")) => Right(scalaxb.fromXML[Add](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LessOrEqual")) => Right(scalaxb.fromXML[LessOrEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Less")) => Right(scalaxb.fromXML[Less](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Equivalent")) => Right(scalaxb.fromXML[Equivalent](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertQuantity")) => Right(scalaxb.fromXML[ConvertQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Implies")) => Right(scalaxb.fromXML[Implies](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Or")) => Right(scalaxb.fromXML[Or](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("And")) => Right(scalaxb.fromXML[And](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Xor")) => Right(scalaxb.fromXML[Xor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CanConvertQuantity")) => Right(scalaxb.fromXML[CanConvertQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Equal")) => Right(scalaxb.fromXML[Equal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("NotEqual")) => Right(scalaxb.fromXML[NotEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Greater")) => Right(scalaxb.fromXML[Greater](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("GreaterOrEqual")) => Right(scalaxb.fromXML[GreaterOrEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Subtract")) => Right(scalaxb.fromXML[Subtract](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Divide")) => Right(scalaxb.fromXML[Divide](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Modulo")) => Right(scalaxb.fromXML[Modulo](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Power")) => Right(scalaxb.fromXML[Power](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LowBoundary")) => Right(scalaxb.fromXML[LowBoundary](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("EndsWith")) => Right(scalaxb.fromXML[EndsWith](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DurationBetween")) => Right(scalaxb.fromXML[DurationBetween](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameOrBefore")) => Right(scalaxb.fromXML[SameOrBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperContains")) => Right(scalaxb.fromXML[ProperContains](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIn")) => Right(scalaxb.fromXML[ProperIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IncludedIn")) => Right(scalaxb.fromXML[IncludedIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIncludedIn")) => Right(scalaxb.fromXML[ProperIncludedIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("After")) => Right(scalaxb.fromXML[After](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MeetsBefore")) => Right(scalaxb.fromXML[MeetsBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Overlaps")) => Right(scalaxb.fromXML[Overlaps](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OverlapsAfter")) => Right(scalaxb.fromXML[OverlapsAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ends")) => Right(scalaxb.fromXML[Ends](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Expand")) => Right(scalaxb.fromXML[Expand](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Subsumes")) => Right(scalaxb.fromXML[Subsumes](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SubsumedBy")) => Right(scalaxb.fromXML[SubsumedBy](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CalculateAgeAt")) => Right(scalaxb.fromXML[CalculateAgeAt](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("NaryExpression")) => Right(scalaxb.fromXML[NaryExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Except")) => Right(scalaxb.fromXML[Except](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Union")) => Right(scalaxb.fromXML[Union](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Coalesce")) => Right(scalaxb.fromXML[Coalesce](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Concatenate")) => Right(scalaxb.fromXML[Concatenate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Intersect")) => Right(scalaxb.fromXML[Intersect](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Round")) => Right(scalaxb.fromXML[Round](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Split")) => Right(scalaxb.fromXML[Split](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PositionOf")) => Right(scalaxb.fromXML[PositionOf](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Substring")) => Right(scalaxb.fromXML[Substring](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Today")) => Right(scalaxb.fromXML[Today](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Date")) => Right(scalaxb.fromXML[Date](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Time")) => Right(scalaxb.fromXML[Time](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Last")) => Right(scalaxb.fromXML[Last](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IndexOf")) => Right(scalaxb.fromXML[IndexOf](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Children")) => Right(scalaxb.fromXML[Children](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Message")) => Right(scalaxb.fromXML[Message](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AnyInValueSet")) => Right(scalaxb.fromXML[AnyInValueSet](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AnyInCodeSystem")) => Right(scalaxb.fromXML[AnyInCodeSystem](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("InCodeSystem")) => Right(scalaxb.fromXML[InCodeSystem](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("InValueSet")) => Right(scalaxb.fromXML[InValueSet](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: OperatorExpression, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: Descendents => scalaxb.toXML[Descendents](x, __namespace, __elementLabel, __scope, true)
      case x: Slice => scalaxb.toXML[Slice](x, __namespace, __elementLabel, __scope, true)
      case x: First => scalaxb.toXML[First](x, __namespace, __elementLabel, __scope, true)
      case x: DateTime => scalaxb.toXML[DateTime](x, __namespace, __elementLabel, __scope, true)
      case x: Now => scalaxb.toXML[Now](x, __namespace, __elementLabel, __scope, true)
      case x: TimeOfDay => scalaxb.toXML[TimeOfDay](x, __namespace, __elementLabel, __scope, true)
      case x: LastPositionOf => scalaxb.toXML[LastPositionOf](x, __namespace, __elementLabel, __scope, true)
      case x: SplitOnMatches => scalaxb.toXML[SplitOnMatches](x, __namespace, __elementLabel, __scope, true)
      case x: Combine => scalaxb.toXML[Combine](x, __namespace, __elementLabel, __scope, true)
      case x: TernaryExpression => scalaxb.toXML[TernaryExpression](x, __namespace, __elementLabel, __scope, true)
      case x: UnaryExpression => scalaxb.toXML[UnaryExpression](x, __namespace, __elementLabel, __scope, true)
      case x: BinaryExpression => scalaxb.toXML[BinaryExpression](x, __namespace, __elementLabel, __scope, true)
      case x: NaryExpression => scalaxb.toXML[NaryExpression](x, __namespace, __elementLabel, __scope, true)
      case x: Round => scalaxb.toXML[Round](x, __namespace, __elementLabel, __scope, true)
      case x: Split => scalaxb.toXML[Split](x, __namespace, __elementLabel, __scope, true)
      case x: PositionOf => scalaxb.toXML[PositionOf](x, __namespace, __elementLabel, __scope, true)
      case x: Substring => scalaxb.toXML[Substring](x, __namespace, __elementLabel, __scope, true)
      case x: Today => scalaxb.toXML[Today](x, __namespace, __elementLabel, __scope, true)
      case x: Date => scalaxb.toXML[Date](x, __namespace, __elementLabel, __scope, true)
      case x: Time => scalaxb.toXML[Time](x, __namespace, __elementLabel, __scope, true)
      case x: Last => scalaxb.toXML[Last](x, __namespace, __elementLabel, __scope, true)
      case x: IndexOf => scalaxb.toXML[IndexOf](x, __namespace, __elementLabel, __scope, true)
      case x: Children => scalaxb.toXML[Children](x, __namespace, __elementLabel, __scope, true)
      case x: Message => scalaxb.toXML[Message](x, __namespace, __elementLabel, __scope, true)
      case x: AnyInValueSet => scalaxb.toXML[AnyInValueSet](x, __namespace, __elementLabel, __scope, true)
      case x: AnyInCodeSystem => scalaxb.toXML[AnyInCodeSystem](x, __namespace, __elementLabel, __scope, true)
      case x: InCodeSystem => scalaxb.toXML[InCodeSystem](x, __namespace, __elementLabel, __scope, true)
      case x: InValueSet => scalaxb.toXML[InValueSet](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_UnaryExpressionFormat extends scalaxb.XMLFormat[UnaryExpression] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, UnaryExpression] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("SingletonFrom")) => Right(scalaxb.fromXML[SingletonFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Distinct")) => Right(scalaxb.fromXML[Distinct](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Flatten")) => Right(scalaxb.fromXML[Flatten](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Start")) => Right(scalaxb.fromXML[Start](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Width")) => Right(scalaxb.fromXML[Width](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimezoneOffsetFrom")) => Right(scalaxb.fromXML[TimezoneOffsetFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimeFrom")) => Right(scalaxb.fromXML[TimeFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Upper")) => Right(scalaxb.fromXML[Upper](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Precision")) => Right(scalaxb.fromXML[Precision](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Successor")) => Right(scalaxb.fromXML[Successor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ln")) => Right(scalaxb.fromXML[Ln](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Negate")) => Right(scalaxb.fromXML[Negate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Truncate")) => Right(scalaxb.fromXML[Truncate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ceiling")) => Right(scalaxb.fromXML[Ceiling](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToTime")) => Right(scalaxb.fromXML[ToTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToString")) => Right(scalaxb.fromXML[ToString](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToChars")) => Right(scalaxb.fromXML[ToChars](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToRatio")) => Right(scalaxb.fromXML[ToRatio](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToQuantity")) => Right(scalaxb.fromXML[ToQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToLong")) => Right(scalaxb.fromXML[ToLong](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToInteger")) => Right(scalaxb.fromXML[ToInteger](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDecimal")) => Right(scalaxb.fromXML[ToDecimal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDateTime")) => Right(scalaxb.fromXML[ToDateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToDate")) => Right(scalaxb.fromXML[ToDate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToConcept")) => Right(scalaxb.fromXML[ToConcept](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToBoolean")) => Right(scalaxb.fromXML[ToBoolean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Convert")) => Right(scalaxb.fromXML[Convert](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Is")) => Right(scalaxb.fromXML[Is](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsFalse")) => Right(scalaxb.fromXML[IsFalse](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsNull")) => Right(scalaxb.fromXML[IsNull](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Not")) => Right(scalaxb.fromXML[Not](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IsTrue")) => Right(scalaxb.fromXML[IsTrue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("As")) => Right(scalaxb.fromXML[As](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CanConvert")) => Right(scalaxb.fromXML[CanConvert](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToBoolean")) => Right(scalaxb.fromXML[ConvertsToBoolean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDate")) => Right(scalaxb.fromXML[ConvertsToDate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDateTime")) => Right(scalaxb.fromXML[ConvertsToDateTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToDecimal")) => Right(scalaxb.fromXML[ConvertsToDecimal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToInteger")) => Right(scalaxb.fromXML[ConvertsToInteger](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToLong")) => Right(scalaxb.fromXML[ConvertsToLong](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToQuantity")) => Right(scalaxb.fromXML[ConvertsToQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToRatio")) => Right(scalaxb.fromXML[ConvertsToRatio](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ToList")) => Right(scalaxb.fromXML[ToList](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToString")) => Right(scalaxb.fromXML[ConvertsToString](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertsToTime")) => Right(scalaxb.fromXML[ConvertsToTime](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Floor")) => Right(scalaxb.fromXML[Floor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Abs")) => Right(scalaxb.fromXML[Abs](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Exp")) => Right(scalaxb.fromXML[Exp](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Predecessor")) => Right(scalaxb.fromXML[Predecessor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Length")) => Right(scalaxb.fromXML[Length](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Lower")) => Right(scalaxb.fromXML[Lower](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateFrom")) => Right(scalaxb.fromXML[DateFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TimezoneFrom")) => Right(scalaxb.fromXML[TimezoneFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DateTimeComponentFrom")) => Right(scalaxb.fromXML[DateTimeComponentFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PointFrom")) => Right(scalaxb.fromXML[PointFrom](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Size")) => Right(scalaxb.fromXML[Size](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("End")) => Right(scalaxb.fromXML[End](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Exists")) => Right(scalaxb.fromXML[Exists](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CalculateAge")) => Right(scalaxb.fromXML[CalculateAge](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ExpandValueSet")) => Right(scalaxb.fromXML[ExpandValueSet](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: UnaryExpression, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: SingletonFrom => scalaxb.toXML[SingletonFrom](x, __namespace, __elementLabel, __scope, true)
      case x: Distinct => scalaxb.toXML[Distinct](x, __namespace, __elementLabel, __scope, true)
      case x: Flatten => scalaxb.toXML[Flatten](x, __namespace, __elementLabel, __scope, true)
      case x: Start => scalaxb.toXML[Start](x, __namespace, __elementLabel, __scope, true)
      case x: Width => scalaxb.toXML[Width](x, __namespace, __elementLabel, __scope, true)
      case x: TimezoneOffsetFrom => scalaxb.toXML[TimezoneOffsetFrom](x, __namespace, __elementLabel, __scope, true)
      case x: TimeFrom => scalaxb.toXML[TimeFrom](x, __namespace, __elementLabel, __scope, true)
      case x: Upper => scalaxb.toXML[Upper](x, __namespace, __elementLabel, __scope, true)
      case x: Precision => scalaxb.toXML[Precision](x, __namespace, __elementLabel, __scope, true)
      case x: Successor => scalaxb.toXML[Successor](x, __namespace, __elementLabel, __scope, true)
      case x: Ln => scalaxb.toXML[Ln](x, __namespace, __elementLabel, __scope, true)
      case x: Negate => scalaxb.toXML[Negate](x, __namespace, __elementLabel, __scope, true)
      case x: Truncate => scalaxb.toXML[Truncate](x, __namespace, __elementLabel, __scope, true)
      case x: Ceiling => scalaxb.toXML[Ceiling](x, __namespace, __elementLabel, __scope, true)
      case x: ToTime => scalaxb.toXML[ToTime](x, __namespace, __elementLabel, __scope, true)
      case x: ToString => scalaxb.toXML[ToString](x, __namespace, __elementLabel, __scope, true)
      case x: ToChars => scalaxb.toXML[ToChars](x, __namespace, __elementLabel, __scope, true)
      case x: ToRatio => scalaxb.toXML[ToRatio](x, __namespace, __elementLabel, __scope, true)
      case x: ToQuantity => scalaxb.toXML[ToQuantity](x, __namespace, __elementLabel, __scope, true)
      case x: ToLong => scalaxb.toXML[ToLong](x, __namespace, __elementLabel, __scope, true)
      case x: ToInteger => scalaxb.toXML[ToInteger](x, __namespace, __elementLabel, __scope, true)
      case x: ToDecimal => scalaxb.toXML[ToDecimal](x, __namespace, __elementLabel, __scope, true)
      case x: ToDateTime => scalaxb.toXML[ToDateTime](x, __namespace, __elementLabel, __scope, true)
      case x: ToDate => scalaxb.toXML[ToDate](x, __namespace, __elementLabel, __scope, true)
      case x: ToConcept => scalaxb.toXML[ToConcept](x, __namespace, __elementLabel, __scope, true)
      case x: ToBoolean => scalaxb.toXML[ToBoolean](x, __namespace, __elementLabel, __scope, true)
      case x: Convert => scalaxb.toXML[Convert](x, __namespace, __elementLabel, __scope, true)
      case x: Is => scalaxb.toXML[Is](x, __namespace, __elementLabel, __scope, true)
      case x: IsFalse => scalaxb.toXML[IsFalse](x, __namespace, __elementLabel, __scope, true)
      case x: IsNull => scalaxb.toXML[IsNull](x, __namespace, __elementLabel, __scope, true)
      case x: Not => scalaxb.toXML[Not](x, __namespace, __elementLabel, __scope, true)
      case x: IsTrue => scalaxb.toXML[IsTrue](x, __namespace, __elementLabel, __scope, true)
      case x: As => scalaxb.toXML[As](x, __namespace, __elementLabel, __scope, true)
      case x: CanConvert => scalaxb.toXML[CanConvert](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToBoolean => scalaxb.toXML[ConvertsToBoolean](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToDate => scalaxb.toXML[ConvertsToDate](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToDateTime => scalaxb.toXML[ConvertsToDateTime](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToDecimal => scalaxb.toXML[ConvertsToDecimal](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToInteger => scalaxb.toXML[ConvertsToInteger](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToLong => scalaxb.toXML[ConvertsToLong](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToQuantity => scalaxb.toXML[ConvertsToQuantity](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToRatio => scalaxb.toXML[ConvertsToRatio](x, __namespace, __elementLabel, __scope, true)
      case x: ToList => scalaxb.toXML[ToList](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToString => scalaxb.toXML[ConvertsToString](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertsToTime => scalaxb.toXML[ConvertsToTime](x, __namespace, __elementLabel, __scope, true)
      case x: Floor => scalaxb.toXML[Floor](x, __namespace, __elementLabel, __scope, true)
      case x: Abs => scalaxb.toXML[Abs](x, __namespace, __elementLabel, __scope, true)
      case x: Exp => scalaxb.toXML[Exp](x, __namespace, __elementLabel, __scope, true)
      case x: Predecessor => scalaxb.toXML[Predecessor](x, __namespace, __elementLabel, __scope, true)
      case x: Length => scalaxb.toXML[Length](x, __namespace, __elementLabel, __scope, true)
      case x: Lower => scalaxb.toXML[Lower](x, __namespace, __elementLabel, __scope, true)
      case x: DateFrom => scalaxb.toXML[DateFrom](x, __namespace, __elementLabel, __scope, true)
      case x: TimezoneFrom => scalaxb.toXML[TimezoneFrom](x, __namespace, __elementLabel, __scope, true)
      case x: DateTimeComponentFrom => scalaxb.toXML[DateTimeComponentFrom](x, __namespace, __elementLabel, __scope, true)
      case x: PointFrom => scalaxb.toXML[PointFrom](x, __namespace, __elementLabel, __scope, true)
      case x: Size => scalaxb.toXML[Size](x, __namespace, __elementLabel, __scope, true)
      case x: End => scalaxb.toXML[End](x, __namespace, __elementLabel, __scope, true)
      case x: Exists => scalaxb.toXML[Exists](x, __namespace, __elementLabel, __scope, true)
      case x: CalculateAge => scalaxb.toXML[CalculateAge](x, __namespace, __elementLabel, __scope, true)
      case x: ExpandValueSet => scalaxb.toXML[ExpandValueSet](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_BinaryExpressionFormat extends scalaxb.XMLFormat[BinaryExpression] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, BinaryExpression] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("Times")) => Right(scalaxb.fromXML[Times](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Collapse")) => Right(scalaxb.fromXML[Collapse](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Starts")) => Right(scalaxb.fromXML[Starts](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OverlapsBefore")) => Right(scalaxb.fromXML[OverlapsBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MeetsAfter")) => Right(scalaxb.fromXML[MeetsAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Meets")) => Right(scalaxb.fromXML[Meets](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Before")) => Right(scalaxb.fromXML[Before](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIncludes")) => Right(scalaxb.fromXML[ProperIncludes](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Includes")) => Right(scalaxb.fromXML[IncludesType](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("In")) => Right(scalaxb.fromXML[In](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Contains")) => Right(scalaxb.fromXML[Contains](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameOrAfter")) => Right(scalaxb.fromXML[SameOrAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameAs")) => Right(scalaxb.fromXML[SameAs](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DifferenceBetween")) => Right(scalaxb.fromXML[DifferenceBetween](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Matches")) => Right(scalaxb.fromXML[Matches](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("StartsWith")) => Right(scalaxb.fromXML[StartsWith](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Indexer")) => Right(scalaxb.fromXML[Indexer](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("HighBoundary")) => Right(scalaxb.fromXML[HighBoundary](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Log")) => Right(scalaxb.fromXML[Log](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("TruncatedDivide")) => Right(scalaxb.fromXML[TruncatedDivide](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Multiply")) => Right(scalaxb.fromXML[Multiply](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Add")) => Right(scalaxb.fromXML[Add](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LessOrEqual")) => Right(scalaxb.fromXML[LessOrEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Less")) => Right(scalaxb.fromXML[Less](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Equivalent")) => Right(scalaxb.fromXML[Equivalent](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ConvertQuantity")) => Right(scalaxb.fromXML[ConvertQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Implies")) => Right(scalaxb.fromXML[Implies](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Or")) => Right(scalaxb.fromXML[Or](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("And")) => Right(scalaxb.fromXML[And](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Xor")) => Right(scalaxb.fromXML[Xor](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CanConvertQuantity")) => Right(scalaxb.fromXML[CanConvertQuantity](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Equal")) => Right(scalaxb.fromXML[Equal](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("NotEqual")) => Right(scalaxb.fromXML[NotEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Greater")) => Right(scalaxb.fromXML[Greater](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("GreaterOrEqual")) => Right(scalaxb.fromXML[GreaterOrEqual](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Subtract")) => Right(scalaxb.fromXML[Subtract](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Divide")) => Right(scalaxb.fromXML[Divide](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Modulo")) => Right(scalaxb.fromXML[Modulo](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Power")) => Right(scalaxb.fromXML[Power](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("LowBoundary")) => Right(scalaxb.fromXML[LowBoundary](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("EndsWith")) => Right(scalaxb.fromXML[EndsWith](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("DurationBetween")) => Right(scalaxb.fromXML[DurationBetween](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SameOrBefore")) => Right(scalaxb.fromXML[SameOrBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperContains")) => Right(scalaxb.fromXML[ProperContains](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIn")) => Right(scalaxb.fromXML[ProperIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("IncludedIn")) => Right(scalaxb.fromXML[IncludedIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ProperIncludedIn")) => Right(scalaxb.fromXML[ProperIncludedIn](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("After")) => Right(scalaxb.fromXML[After](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("MeetsBefore")) => Right(scalaxb.fromXML[MeetsBefore](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Overlaps")) => Right(scalaxb.fromXML[Overlaps](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("OverlapsAfter")) => Right(scalaxb.fromXML[OverlapsAfter](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Ends")) => Right(scalaxb.fromXML[Ends](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Expand")) => Right(scalaxb.fromXML[Expand](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Subsumes")) => Right(scalaxb.fromXML[Subsumes](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("SubsumedBy")) => Right(scalaxb.fromXML[SubsumedBy](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("CalculateAgeAt")) => Right(scalaxb.fromXML[CalculateAgeAt](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: BinaryExpression, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: Times => scalaxb.toXML[Times](x, __namespace, __elementLabel, __scope, true)
      case x: Collapse => scalaxb.toXML[Collapse](x, __namespace, __elementLabel, __scope, true)
      case x: Starts => scalaxb.toXML[Starts](x, __namespace, __elementLabel, __scope, true)
      case x: OverlapsBefore => scalaxb.toXML[OverlapsBefore](x, __namespace, __elementLabel, __scope, true)
      case x: MeetsAfter => scalaxb.toXML[MeetsAfter](x, __namespace, __elementLabel, __scope, true)
      case x: Meets => scalaxb.toXML[Meets](x, __namespace, __elementLabel, __scope, true)
      case x: Before => scalaxb.toXML[Before](x, __namespace, __elementLabel, __scope, true)
      case x: ProperIncludes => scalaxb.toXML[ProperIncludes](x, __namespace, __elementLabel, __scope, true)
      case x: IncludesType => scalaxb.toXML[IncludesType](x, __namespace, __elementLabel, __scope, true)
      case x: In => scalaxb.toXML[In](x, __namespace, __elementLabel, __scope, true)
      case x: Contains => scalaxb.toXML[Contains](x, __namespace, __elementLabel, __scope, true)
      case x: SameOrAfter => scalaxb.toXML[SameOrAfter](x, __namespace, __elementLabel, __scope, true)
      case x: SameAs => scalaxb.toXML[SameAs](x, __namespace, __elementLabel, __scope, true)
      case x: DifferenceBetween => scalaxb.toXML[DifferenceBetween](x, __namespace, __elementLabel, __scope, true)
      case x: Matches => scalaxb.toXML[Matches](x, __namespace, __elementLabel, __scope, true)
      case x: StartsWith => scalaxb.toXML[StartsWith](x, __namespace, __elementLabel, __scope, true)
      case x: Indexer => scalaxb.toXML[Indexer](x, __namespace, __elementLabel, __scope, true)
      case x: HighBoundary => scalaxb.toXML[HighBoundary](x, __namespace, __elementLabel, __scope, true)
      case x: Log => scalaxb.toXML[Log](x, __namespace, __elementLabel, __scope, true)
      case x: TruncatedDivide => scalaxb.toXML[TruncatedDivide](x, __namespace, __elementLabel, __scope, true)
      case x: Multiply => scalaxb.toXML[Multiply](x, __namespace, __elementLabel, __scope, true)
      case x: Add => scalaxb.toXML[Add](x, __namespace, __elementLabel, __scope, true)
      case x: LessOrEqual => scalaxb.toXML[LessOrEqual](x, __namespace, __elementLabel, __scope, true)
      case x: Less => scalaxb.toXML[Less](x, __namespace, __elementLabel, __scope, true)
      case x: Equivalent => scalaxb.toXML[Equivalent](x, __namespace, __elementLabel, __scope, true)
      case x: ConvertQuantity => scalaxb.toXML[ConvertQuantity](x, __namespace, __elementLabel, __scope, true)
      case x: Implies => scalaxb.toXML[Implies](x, __namespace, __elementLabel, __scope, true)
      case x: Or => scalaxb.toXML[Or](x, __namespace, __elementLabel, __scope, true)
      case x: And => scalaxb.toXML[And](x, __namespace, __elementLabel, __scope, true)
      case x: Xor => scalaxb.toXML[Xor](x, __namespace, __elementLabel, __scope, true)
      case x: CanConvertQuantity => scalaxb.toXML[CanConvertQuantity](x, __namespace, __elementLabel, __scope, true)
      case x: Equal => scalaxb.toXML[Equal](x, __namespace, __elementLabel, __scope, true)
      case x: NotEqual => scalaxb.toXML[NotEqual](x, __namespace, __elementLabel, __scope, true)
      case x: Greater => scalaxb.toXML[Greater](x, __namespace, __elementLabel, __scope, true)
      case x: GreaterOrEqual => scalaxb.toXML[GreaterOrEqual](x, __namespace, __elementLabel, __scope, true)
      case x: Subtract => scalaxb.toXML[Subtract](x, __namespace, __elementLabel, __scope, true)
      case x: Divide => scalaxb.toXML[Divide](x, __namespace, __elementLabel, __scope, true)
      case x: Modulo => scalaxb.toXML[Modulo](x, __namespace, __elementLabel, __scope, true)
      case x: Power => scalaxb.toXML[Power](x, __namespace, __elementLabel, __scope, true)
      case x: LowBoundary => scalaxb.toXML[LowBoundary](x, __namespace, __elementLabel, __scope, true)
      case x: EndsWith => scalaxb.toXML[EndsWith](x, __namespace, __elementLabel, __scope, true)
      case x: DurationBetween => scalaxb.toXML[DurationBetween](x, __namespace, __elementLabel, __scope, true)
      case x: SameOrBefore => scalaxb.toXML[SameOrBefore](x, __namespace, __elementLabel, __scope, true)
      case x: ProperContains => scalaxb.toXML[ProperContains](x, __namespace, __elementLabel, __scope, true)
      case x: ProperIn => scalaxb.toXML[ProperIn](x, __namespace, __elementLabel, __scope, true)
      case x: IncludedIn => scalaxb.toXML[IncludedIn](x, __namespace, __elementLabel, __scope, true)
      case x: ProperIncludedIn => scalaxb.toXML[ProperIncludedIn](x, __namespace, __elementLabel, __scope, true)
      case x: After => scalaxb.toXML[After](x, __namespace, __elementLabel, __scope, true)
      case x: MeetsBefore => scalaxb.toXML[MeetsBefore](x, __namespace, __elementLabel, __scope, true)
      case x: Overlaps => scalaxb.toXML[Overlaps](x, __namespace, __elementLabel, __scope, true)
      case x: OverlapsAfter => scalaxb.toXML[OverlapsAfter](x, __namespace, __elementLabel, __scope, true)
      case x: Ends => scalaxb.toXML[Ends](x, __namespace, __elementLabel, __scope, true)
      case x: Expand => scalaxb.toXML[Expand](x, __namespace, __elementLabel, __scope, true)
      case x: Subsumes => scalaxb.toXML[Subsumes](x, __namespace, __elementLabel, __scope, true)
      case x: SubsumedBy => scalaxb.toXML[SubsumedBy](x, __namespace, __elementLabel, __scope, true)
      case x: CalculateAgeAt => scalaxb.toXML[CalculateAgeAt](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_TernaryExpressionFormat extends scalaxb.XMLFormat[TernaryExpression] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, TernaryExpression] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("ReplaceMatches")) => Right(scalaxb.fromXML[ReplaceMatches](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: TernaryExpression, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: ReplaceMatches => scalaxb.toXML[ReplaceMatches](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }
  trait Default_NaryExpressionFormat extends scalaxb.XMLFormat[NaryExpression] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, NaryExpression] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("Except")) => Right(scalaxb.fromXML[Except](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Union")) => Right(scalaxb.fromXML[Union](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Coalesce")) => Right(scalaxb.fromXML[Coalesce](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Concatenate")) => Right(scalaxb.fromXML[Concatenate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Intersect")) => Right(scalaxb.fromXML[Intersect](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: NaryExpression, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: Except => scalaxb.toXML[Except](x, __namespace, __elementLabel, __scope, true)
      case x: Union => scalaxb.toXML[Union](x, __namespace, __elementLabel, __scope, true)
      case x: Coalesce => scalaxb.toXML[Coalesce](x, __namespace, __elementLabel, __scope, true)
      case x: Concatenate => scalaxb.toXML[Concatenate](x, __namespace, __elementLabel, __scope, true)
      case x: Intersect => scalaxb.toXML[Intersect](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  def build_AccessModifierFormat = new Default_AccessModifierFormat {}
  trait Default_AccessModifierFormat extends scalaxb.XMLFormat[AccessModifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): AccessModifier =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, AccessModifier] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Public")) => Public
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Private")) => Private

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, AccessModifier] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: AccessModifier, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_ExpressionDefableFormat extends scalaxb.XMLFormat[ExpressionDefable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ExpressionDefable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("FunctionDef")) => Right(scalaxb.fromXML[FunctionDef](node, stack))
          case _ => Right(scalaxb.fromXML[ExpressionDef](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: ExpressionDefable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: FunctionDef => scalaxb.toXML[FunctionDef](x, __namespace, __elementLabel, __scope, true)
      case x: ExpressionDef => scalaxb.toXML[ExpressionDef](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_ExpressionDefFormat extends scalaxb.ElemNameParser[ExpressionDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ExpressionDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ExpressionDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "expression")) ^^
      { case p1 ~ p2 ~ p3 =>
      ExpressionDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@context").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@context" -> _ },
        (node \ "@accessLevel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[AccessModifier](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[AccessModifier](scala.xml.Text("Public"), scalaxb.ElemName(node) :: stack))) map { "@accessLevel" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ExpressionDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@context", _) => __obj.context foreach { x => attr = scala.xml.Attribute(null, "context", x.toString, attr) }
        case ("@accessLevel", _) => if (__obj.accessLevel.toString != "Public") attr = scala.xml.Attribute(null, "accessLevel", __obj.accessLevel.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ExpressionDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.expression map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("expression"), __scope, false) } getOrElse {Nil})

  }

  trait Default_FunctionDefFormat extends scalaxb.ElemNameParser[FunctionDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("FunctionDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[FunctionDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "expression")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      FunctionDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[OperandDef](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@context").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@context" -> _ },
        (node \ "@accessLevel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[AccessModifier](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[AccessModifier](scala.xml.Text("Public"), scalaxb.ElemName(node) :: stack))) map { "@accessLevel" -> _ },
        (node \ "@external").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@external" -> _ },
        (node \ "@fluent").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@fluent" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: FunctionDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@context", _) => __obj.context foreach { x => attr = scala.xml.Attribute(null, "context", x.toString, attr) }
        case ("@accessLevel", _) => if (__obj.accessLevel.toString != "Public") attr = scala.xml.Attribute(null, "accessLevel", __obj.accessLevel.toString, attr)
        case ("@external", _) => __obj.external foreach { x => attr = scala.xml.Attribute(null, "external", x.toString, attr) }
        case ("@fluent", _) => __obj.fluent foreach { x => attr = scala.xml.Attribute(null, "fluent", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: FunctionDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.expression map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("expression"), __scope, false) } getOrElse {Nil},
        __obj.operand flatMap { scalaxb.toXML[OperandDef](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ExpressionRefableFormat extends scalaxb.XMLFormat[ExpressionRefable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ExpressionRefable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("FunctionRef")) => Right(scalaxb.fromXML[FunctionRef](node, stack))
          case _ => Right(scalaxb.fromXML[ExpressionRef](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: ExpressionRefable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: FunctionRef => scalaxb.toXML[FunctionRef](x, __namespace, __elementLabel, __scope, true)
      case x: ExpressionRef => scalaxb.toXML[ExpressionRef](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_ExpressionRefFormat extends scalaxb.ElemNameParser[ExpressionRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ExpressionRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ExpressionRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ExpressionRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@libraryName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ExpressionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@libraryName", _) => __obj.libraryName foreach { x => attr = scala.xml.Attribute(null, "libraryName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ExpressionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_FunctionRefFormat extends scalaxb.ElemNameParser[FunctionRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("FunctionRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[FunctionRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      FunctionRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@libraryName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: FunctionRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@libraryName", _) => __obj.libraryName foreach { x => attr = scala.xml.Attribute(null, "libraryName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: FunctionRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ParameterDefFormat extends scalaxb.ElemNameParser[ParameterDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ParameterDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ParameterDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "default")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "parameterTypeSpecifier")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ParameterDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@parameterType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@parameterType" -> _ },
        (node \ "@accessLevel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[AccessModifier](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[AccessModifier](scala.xml.Text("Public"), scalaxb.ElemName(node) :: stack))) map { "@accessLevel" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ParameterDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@parameterType", _) => __obj.parameterType foreach { x => attr = scala.xml.Attribute(null, "parameterType", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@accessLevel", _) => if (__obj.accessLevel.toString != "Public") attr = scala.xml.Attribute(null, "accessLevel", __obj.accessLevel.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ParameterDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.default map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("default"), __scope, false) } getOrElse {Nil},
        __obj.parameterTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("parameterTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ParameterRefFormat extends scalaxb.ElemNameParser[ParameterRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ParameterRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ParameterRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ParameterRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@libraryName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ParameterRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@libraryName", _) => __obj.libraryName foreach { x => attr = scala.xml.Attribute(null, "libraryName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ParameterRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_OperandDefFormat extends scalaxb.ElemNameParser[OperandDef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("OperandDef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[OperandDef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operandTypeSpecifier")) ^^
      { case p1 ~ p2 ~ p3 =>
      OperandDef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@operandType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@operandType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: OperandDef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@operandType", _) => __obj.operandType foreach { x => attr = scala.xml.Attribute(null, "operandType", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: OperandDef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.operandTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("operandTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_OperandRefFormat extends scalaxb.ElemNameParser[OperandRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("OperandRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[OperandRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      OperandRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: OperandRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: OperandRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_IdentifierRefFormat extends scalaxb.ElemNameParser[IdentifierRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("IdentifierRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IdentifierRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      IdentifierRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@libraryName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@libraryName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IdentifierRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@libraryName", _) => __obj.libraryName foreach { x => attr = scala.xml.Attribute(null, "libraryName", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IdentifierRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_LiteralFormat extends scalaxb.ElemNameParser[Literal] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Literal")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Literal] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      Literal(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@valueType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@valueType" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.DataRecord[Any]](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Literal, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@valueType", _) => attr = scala.xml.Attribute(null, "valueType", scalaxb.Helper.toString(__obj.valueType, __scope), attr)
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Literal, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_TupleElementFormat extends scalaxb.ElemNameParser[TupleElement] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("TupleElement")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TupleElement] =
      phrase((scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "value")) ^^
      { case p1 =>
      TupleElement(scalaxb.fromXML[Expression](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TupleElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TupleElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[Expression](__obj.value, Some("urn:hl7-org:elm:r1"), Some("value"), __scope, false))
  }

  trait Default_TupleFormat extends scalaxb.ElemNameParser[Tuple] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Tuple")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Tuple] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "element")) ^^
      { case p1 ~ p2 ~ p3 =>
      Tuple(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TupleElement](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Tuple, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Tuple, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.element flatMap { scalaxb.toXML[TupleElement](_, Some("urn:hl7-org:elm:r1"), Some("element"), __scope, false) })

  }

  trait Default_InstanceElementFormat extends scalaxb.ElemNameParser[InstanceElement] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("InstanceElement")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[InstanceElement] =
      phrase((scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "value")) ^^
      { case p1 =>
      InstanceElement(scalaxb.fromXML[Expression](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: InstanceElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: InstanceElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[Expression](__obj.value, Some("urn:hl7-org:elm:r1"), Some("value"), __scope, false))
  }

  trait Default_InstanceFormat extends scalaxb.ElemNameParser[Instance] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Instance")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Instance] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "element")) ^^
      { case p1 ~ p2 ~ p3 =>
      Instance(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[InstanceElement](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@classType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@classType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Instance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@classType", _) => attr = scala.xml.Attribute(null, "classType", scalaxb.Helper.toString(__obj.classType, __scope), attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Instance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.element flatMap { scalaxb.toXML[InstanceElement](_, Some("urn:hl7-org:elm:r1"), Some("element"), __scope, false) })

  }

  trait Default_IntervalFormat extends scalaxb.ElemNameParser[Interval] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Interval")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Interval] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "low")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "lowClosedExpression")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "high")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "highClosedExpression")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Interval(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@lowClosed").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack))) map { "@lowClosed" -> _ },
        (node \ "@highClosed").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack))) map { "@highClosed" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Interval, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@lowClosed", _) => if (__obj.lowClosed.toString != "true") attr = scala.xml.Attribute(null, "lowClosed", __obj.lowClosed.toString, attr)
        case ("@highClosed", _) => if (__obj.highClosed.toString != "true") attr = scala.xml.Attribute(null, "highClosed", __obj.highClosed.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Interval, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.low map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("low"), __scope, false) } getOrElse {Nil},
        __obj.lowClosedExpression map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("lowClosedExpression"), __scope, false) } getOrElse {Nil},
        __obj.high map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("high"), __scope, false) } getOrElse {Nil},
        __obj.highClosedExpression map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("highClosedExpression"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ListTypeFormat extends scalaxb.ElemNameParser[ListType] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("List")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ListType] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "typeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "element")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ListType(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ListType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ListType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.typeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("typeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.element flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("element"), __scope, false) })

  }

  trait Default_AndFormat extends scalaxb.ElemNameParser[And] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("And")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[And] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      And(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: And, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: And, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_OrFormat extends scalaxb.ElemNameParser[Or] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Or")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Or] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Or(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Or, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Or, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_XorFormat extends scalaxb.ElemNameParser[Xor] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Xor")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Xor] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Xor(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Xor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Xor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ImpliesFormat extends scalaxb.ElemNameParser[Implies] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Implies")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Implies] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Implies(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Implies, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Implies, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_NotFormat extends scalaxb.ElemNameParser[Not] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Not")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Not] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Not(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Not, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Not, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_IfFormat extends scalaxb.ElemNameParser[If] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("If")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[If] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "condition")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "then")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "else")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      If(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p5, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: If, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: If, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.condition, Some("urn:hl7-org:elm:r1"), Some("condition"), __scope, false),
        scalaxb.toXML[Expression](__obj.then, Some("urn:hl7-org:elm:r1"), Some("then"), __scope, false),
        scalaxb.toXML[Expression](__obj.elseValue, Some("urn:hl7-org:elm:r1"), Some("else"), __scope, false))

  }

  trait Default_CaseItemFormat extends scalaxb.ElemNameParser[CaseItem] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CaseItem")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CaseItem] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "when")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "then")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      CaseItem(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CaseItem, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CaseItem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.when, Some("urn:hl7-org:elm:r1"), Some("when"), __scope, false),
        scalaxb.toXML[Expression](__obj.then, Some("urn:hl7-org:elm:r1"), Some("then"), __scope, false))

  }

  trait Default_CaseFormat extends scalaxb.ElemNameParser[Case] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Case")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Case] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "comparand")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "caseItem")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "else")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      Case(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[CaseItem](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p5, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Case, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Case, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.comparand map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("comparand"), __scope, false) } getOrElse {Nil},
        __obj.caseItem flatMap { scalaxb.toXML[CaseItem](_, Some("urn:hl7-org:elm:r1"), Some("caseItem"), __scope, false) },
        scalaxb.toXML[Expression](__obj.elseValue, Some("urn:hl7-org:elm:r1"), Some("else"), __scope, false))

  }

  trait Default_NullFormat extends scalaxb.ElemNameParser[Null] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Null")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Null] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      Null(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@valueType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@valueType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Null, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@valueType", _) => __obj.valueType foreach { x => attr = scala.xml.Attribute(null, "valueType", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Null, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_IsNullFormat extends scalaxb.ElemNameParser[IsNull] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("IsNull")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IsNull] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IsNull(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IsNull, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IsNull, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_IsTrueFormat extends scalaxb.ElemNameParser[IsTrue] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("IsTrue")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IsTrue] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IsTrue(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IsTrue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IsTrue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_IsFalseFormat extends scalaxb.ElemNameParser[IsFalse] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("IsFalse")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IsFalse] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IsFalse(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IsFalse, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IsFalse, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_CoalesceFormat extends scalaxb.ElemNameParser[Coalesce] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Coalesce")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Coalesce] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Coalesce(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Coalesce, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Coalesce, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_IsFormat extends scalaxb.ElemNameParser[Is] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Is")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Is] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "isTypeSpecifier")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      Is(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@isType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@isType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Is, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@isType", _) => __obj.isType foreach { x => attr = scala.xml.Attribute(null, "isType", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Is, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false),
        __obj.isTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("isTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AsFormat extends scalaxb.ElemNameParser[As] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("As")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[As] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "asTypeSpecifier")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      As(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@asType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@asType" -> _ },
        (node \ "@strict").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@strict" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: As, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@asType", _) => __obj.asType foreach { x => attr = scala.xml.Attribute(null, "asType", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@strict", _) => if (__obj.strict.toString != "false") attr = scala.xml.Attribute(null, "strict", __obj.strict.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: As, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false),
        __obj.asTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("asTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ConvertFormat extends scalaxb.ElemNameParser[Convert] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Convert")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Convert] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "toTypeSpecifier")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      Convert(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@toType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@toType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Convert, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@toType", _) => __obj.toType foreach { x => attr = scala.xml.Attribute(null, "toType", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Convert, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false),
        __obj.toTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("toTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CanConvertFormat extends scalaxb.ElemNameParser[CanConvert] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CanConvert")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CanConvert] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "toTypeSpecifier")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      CanConvert(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@toType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@toType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CanConvert, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@toType", _) => __obj.toType foreach { x => attr = scala.xml.Attribute(null, "toType", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CanConvert, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false),
        __obj.toTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("toTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ToBooleanFormat extends scalaxb.ElemNameParser[ToBoolean] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToBoolean")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToBoolean] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToBoolean(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToBoolean, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToBoolean, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToBooleanFormat extends scalaxb.ElemNameParser[ConvertsToBoolean] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToBoolean")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToBoolean] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToBoolean(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToBoolean, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToBoolean, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToConceptFormat extends scalaxb.ElemNameParser[ToConcept] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToConcept")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToConcept] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToConcept(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToConcept, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToConcept, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToDateFormat extends scalaxb.ElemNameParser[ConvertsToDate] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToDate")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToDate] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToDate(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToDate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToDate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToDateFormat extends scalaxb.ElemNameParser[ToDate] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToDate")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToDate] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToDate(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToDate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToDate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToDateTimeFormat extends scalaxb.ElemNameParser[ConvertsToDateTime] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToDateTime")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToDateTime] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToDateTime(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToDateTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToDateTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToDateTimeFormat extends scalaxb.ElemNameParser[ToDateTime] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToDateTime")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToDateTime] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToDateTime(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToDateTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToDateTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToDecimalFormat extends scalaxb.ElemNameParser[ConvertsToDecimal] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToDecimal")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToDecimal] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToDecimal(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToDecimal, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToDecimal, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToDecimalFormat extends scalaxb.ElemNameParser[ToDecimal] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToDecimal")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToDecimal] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToDecimal(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToDecimal, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToDecimal, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToIntegerFormat extends scalaxb.ElemNameParser[ConvertsToInteger] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToInteger")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToInteger] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToInteger(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToInteger, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToInteger, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToIntegerFormat extends scalaxb.ElemNameParser[ToInteger] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToInteger")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToInteger] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToInteger(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToInteger, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToInteger, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToLongFormat extends scalaxb.ElemNameParser[ConvertsToLong] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToLong")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToLong] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToLong(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToLong, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToLong, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToLongFormat extends scalaxb.ElemNameParser[ToLong] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToLong")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToLong] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToLong(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToLong, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToLong, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToQuantityFormat extends scalaxb.ElemNameParser[ConvertsToQuantity] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToQuantity")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToQuantity] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToQuantity(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToQuantity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToQuantity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToQuantityFormat extends scalaxb.ElemNameParser[ToQuantity] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToQuantity")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToQuantity] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToQuantity(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToQuantity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToQuantity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToRatioFormat extends scalaxb.ElemNameParser[ConvertsToRatio] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToRatio")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToRatio] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToRatio(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToRatio, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToRatio, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToRatioFormat extends scalaxb.ElemNameParser[ToRatio] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToRatio")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToRatio] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToRatio(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToRatio, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToRatio, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToListFormat extends scalaxb.ElemNameParser[ToList] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToList")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToList] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToList(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToList, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToList, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToCharsFormat extends scalaxb.ElemNameParser[ToChars] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToChars")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToChars] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToChars(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToChars, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToChars, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToStringFormat extends scalaxb.ElemNameParser[ConvertsToString] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToString")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToString] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToString(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToString, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToString, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToStringFormat extends scalaxb.ElemNameParser[ToString] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToString")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToString] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToString(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToString, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToString, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ConvertsToTimeFormat extends scalaxb.ElemNameParser[ConvertsToTime] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertsToTime")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertsToTime] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertsToTime(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertsToTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertsToTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ToTimeFormat extends scalaxb.ElemNameParser[ToTime] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ToTime")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ToTime] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ToTime(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ToTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ToTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_CanConvertQuantityFormat extends scalaxb.ElemNameParser[CanConvertQuantity] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("CanConvertQuantity")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[CanConvertQuantity] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      CanConvertQuantity(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: CanConvertQuantity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: CanConvertQuantity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ConvertQuantityFormat extends scalaxb.ElemNameParser[ConvertQuantity] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ConvertQuantity")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConvertQuantity] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ConvertQuantity(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConvertQuantity, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConvertQuantity, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_EqualFormat extends scalaxb.ElemNameParser[Equal] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Equal")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Equal] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Equal(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Equal, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Equal, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_EquivalentFormat extends scalaxb.ElemNameParser[Equivalent] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Equivalent")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Equivalent] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Equivalent(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Equivalent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Equivalent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_NotEqualFormat extends scalaxb.ElemNameParser[NotEqual] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("NotEqual")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[NotEqual] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      NotEqual(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: NotEqual, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: NotEqual, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_LessFormat extends scalaxb.ElemNameParser[Less] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Less")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Less] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Less(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Less, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Less, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_GreaterFormat extends scalaxb.ElemNameParser[Greater] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Greater")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Greater] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Greater(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Greater, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Greater, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_LessOrEqualFormat extends scalaxb.ElemNameParser[LessOrEqual] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("LessOrEqual")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[LessOrEqual] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      LessOrEqual(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: LessOrEqual, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LessOrEqual, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_GreaterOrEqualFormat extends scalaxb.ElemNameParser[GreaterOrEqual] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("GreaterOrEqual")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[GreaterOrEqual] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      GreaterOrEqual(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: GreaterOrEqual, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: GreaterOrEqual, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_AddFormat extends scalaxb.ElemNameParser[Add] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Add")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Add] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Add(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Add, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Add, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_SubtractFormat extends scalaxb.ElemNameParser[Subtract] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Subtract")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Subtract] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Subtract(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Subtract, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Subtract, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_MultiplyFormat extends scalaxb.ElemNameParser[Multiply] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Multiply")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Multiply] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Multiply(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Multiply, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Multiply, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_DivideFormat extends scalaxb.ElemNameParser[Divide] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Divide")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Divide] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Divide(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Divide, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Divide, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_TruncatedDivideFormat extends scalaxb.ElemNameParser[TruncatedDivide] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("TruncatedDivide")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TruncatedDivide] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      TruncatedDivide(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TruncatedDivide, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TruncatedDivide, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ModuloFormat extends scalaxb.ElemNameParser[Modulo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Modulo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Modulo] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Modulo(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Modulo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Modulo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_CeilingFormat extends scalaxb.ElemNameParser[Ceiling] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Ceiling")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Ceiling] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Ceiling(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Ceiling, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Ceiling, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_FloorFormat extends scalaxb.ElemNameParser[Floor] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Floor")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Floor] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Floor(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Floor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Floor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_TruncateFormat extends scalaxb.ElemNameParser[Truncate] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Truncate")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Truncate] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Truncate(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Truncate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Truncate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_AbsFormat extends scalaxb.ElemNameParser[Abs] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Abs")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Abs] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Abs(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Abs, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Abs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_NegateFormat extends scalaxb.ElemNameParser[Negate] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Negate")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Negate] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Negate(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Negate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Negate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_RoundFormat extends scalaxb.ElemNameParser[Round] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Round")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Round] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "precision")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      Round(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Round, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Round, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false),
        __obj.precision map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("precision"), __scope, false) } getOrElse {Nil})

  }

  trait Default_LnFormat extends scalaxb.ElemNameParser[Ln] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Ln")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Ln] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Ln(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Ln, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Ln, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ExpFormat extends scalaxb.ElemNameParser[Exp] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Exp")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Exp] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Exp(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Exp, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Exp, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_LogFormat extends scalaxb.ElemNameParser[Log] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Log")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Log] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Log(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Log, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Log, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_PowerFormat extends scalaxb.ElemNameParser[Power] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Power")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Power] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Power(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Power, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Power, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_SuccessorFormat extends scalaxb.ElemNameParser[Successor] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Successor")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Successor] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Successor(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Successor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Successor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_PredecessorFormat extends scalaxb.ElemNameParser[Predecessor] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Predecessor")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Predecessor] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Predecessor(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Predecessor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Predecessor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_MinValueFormat extends scalaxb.ElemNameParser[MinValue] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("MinValue")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[MinValue] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      MinValue(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@valueType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@valueType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: MinValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@valueType", _) => attr = scala.xml.Attribute(null, "valueType", scalaxb.Helper.toString(__obj.valueType, __scope), attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: MinValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_MaxValueFormat extends scalaxb.ElemNameParser[MaxValue] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("MaxValue")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[MaxValue] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      MaxValue(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@valueType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@valueType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: MaxValue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@valueType", _) => attr = scala.xml.Attribute(null, "valueType", scalaxb.Helper.toString(__obj.valueType, __scope), attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: MaxValue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_PrecisionFormat extends scalaxb.ElemNameParser[Precision] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Precision")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Precision] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Precision(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Precision, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Precision, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_LowBoundaryFormat extends scalaxb.ElemNameParser[LowBoundary] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("LowBoundary")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[LowBoundary] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      LowBoundary(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: LowBoundary, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LowBoundary, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_HighBoundaryFormat extends scalaxb.ElemNameParser[HighBoundary] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("HighBoundary")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[HighBoundary] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      HighBoundary(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: HighBoundary, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: HighBoundary, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ConcatenateFormat extends scalaxb.ElemNameParser[Concatenate] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Concatenate")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Concatenate] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Concatenate(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Concatenate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Concatenate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_CombineFormat extends scalaxb.ElemNameParser[Combine] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Combine")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Combine] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "separator")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      Combine(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Combine, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Combine, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false),
        __obj.separator map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("separator"), __scope, false) } getOrElse {Nil})

  }

  trait Default_SplitFormat extends scalaxb.ElemNameParser[Split] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Split")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Split] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "stringToSplit")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "separator")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      Split(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Split, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Split, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.stringToSplit, Some("urn:hl7-org:elm:r1"), Some("stringToSplit"), __scope, false),
        __obj.separator map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("separator"), __scope, false) } getOrElse {Nil})

  }

  trait Default_SplitOnMatchesFormat extends scalaxb.ElemNameParser[SplitOnMatches] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("SplitOnMatches")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SplitOnMatches] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "stringToSplit")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "separatorPattern")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      SplitOnMatches(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p5, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SplitOnMatches, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SplitOnMatches, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.stringToSplit, Some("urn:hl7-org:elm:r1"), Some("stringToSplit"), __scope, false),
        scalaxb.toXML[Expression](__obj.separatorPattern, Some("urn:hl7-org:elm:r1"), Some("separatorPattern"), __scope, false))

  }

  trait Default_LengthFormat extends scalaxb.ElemNameParser[Length] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Length")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Length] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Length(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Length, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Length, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_UpperFormat extends scalaxb.ElemNameParser[Upper] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Upper")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Upper] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Upper(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Upper, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Upper, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_LowerFormat extends scalaxb.ElemNameParser[Lower] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Lower")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Lower] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Lower(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Lower, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Lower, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_IndexerFormat extends scalaxb.ElemNameParser[Indexer] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Indexer")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Indexer] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Indexer(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Indexer, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Indexer, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_PositionOfFormat extends scalaxb.ElemNameParser[PositionOf] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("PositionOf")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[PositionOf] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "pattern")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "string")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      PositionOf(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p5, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: PositionOf, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: PositionOf, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.pattern, Some("urn:hl7-org:elm:r1"), Some("pattern"), __scope, false),
        scalaxb.toXML[Expression](__obj.string, Some("urn:hl7-org:elm:r1"), Some("string"), __scope, false))

  }

  trait Default_LastPositionOfFormat extends scalaxb.ElemNameParser[LastPositionOf] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("LastPositionOf")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[LastPositionOf] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "pattern")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "string")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      LastPositionOf(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p5, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: LastPositionOf, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LastPositionOf, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.pattern, Some("urn:hl7-org:elm:r1"), Some("pattern"), __scope, false),
        scalaxb.toXML[Expression](__obj.string, Some("urn:hl7-org:elm:r1"), Some("string"), __scope, false))

  }

  trait Default_SubstringFormat extends scalaxb.ElemNameParser[Substring] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Substring")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Substring] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "stringToSub")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "startIndex")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "length")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Substring(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p5, scalaxb.ElemName(node) :: stack),
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Substring, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Substring, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.stringToSub, Some("urn:hl7-org:elm:r1"), Some("stringToSub"), __scope, false),
        scalaxb.toXML[Expression](__obj.startIndex, Some("urn:hl7-org:elm:r1"), Some("startIndex"), __scope, false),
        __obj.length map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("length"), __scope, false) } getOrElse {Nil})

  }

  trait Default_StartsWithFormat extends scalaxb.ElemNameParser[StartsWith] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("StartsWith")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[StartsWith] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      StartsWith(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: StartsWith, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: StartsWith, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_EndsWithFormat extends scalaxb.ElemNameParser[EndsWith] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("EndsWith")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[EndsWith] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      EndsWith(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: EndsWith, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: EndsWith, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_MatchesFormat extends scalaxb.ElemNameParser[Matches] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Matches")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Matches] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Matches(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Matches, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Matches, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ReplaceMatchesFormat extends scalaxb.ElemNameParser[ReplaceMatches] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ReplaceMatches")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ReplaceMatches] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ReplaceMatches(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ReplaceMatches, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ReplaceMatches, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  def build_DateTimePrecisionFormat = new Default_DateTimePrecisionFormat {}
  trait Default_DateTimePrecisionFormat extends scalaxb.XMLFormat[DateTimePrecision] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): DateTimePrecision =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, DateTimePrecision] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Year")) => Year
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Month")) => Month
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Week")) => Week
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Day")) => Day
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Hour")) => Hour
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Minute")) => Minute
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Second")) => Second
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Millisecond")) => Millisecond

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, DateTimePrecision] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: DateTimePrecision, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_DurationBetweenFormat extends scalaxb.ElemNameParser[DurationBetween] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("DurationBetween")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[DurationBetween] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      DurationBetween(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: DurationBetween, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: DurationBetween, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_DifferenceBetweenFormat extends scalaxb.ElemNameParser[DifferenceBetween] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("DifferenceBetween")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[DifferenceBetween] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      DifferenceBetween(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: DifferenceBetween, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: DifferenceBetween, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_DateFromFormat extends scalaxb.ElemNameParser[DateFrom] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("DateFrom")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[DateFrom] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      DateFrom(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: DateFrom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: DateFrom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_TimeFromFormat extends scalaxb.ElemNameParser[TimeFrom] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("TimeFrom")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TimeFrom] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      TimeFrom(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TimeFrom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TimeFrom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_TimezoneFromFormat extends scalaxb.ElemNameParser[TimezoneFrom] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("TimezoneFrom")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TimezoneFrom] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      TimezoneFrom(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TimezoneFrom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TimezoneFrom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_TimezoneOffsetFromFormat extends scalaxb.ElemNameParser[TimezoneOffsetFrom] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("TimezoneOffsetFrom")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TimezoneOffsetFrom] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      TimezoneOffsetFrom(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TimezoneOffsetFrom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TimezoneOffsetFrom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_DateTimeComponentFromFormat extends scalaxb.ElemNameParser[DateTimeComponentFrom] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("DateTimeComponentFrom")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[DateTimeComponentFrom] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      DateTimeComponentFrom(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: DateTimeComponentFrom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: DateTimeComponentFrom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_TimeOfDayFormat extends scalaxb.ElemNameParser[TimeOfDay] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("TimeOfDay")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TimeOfDay] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ^^
      { case p1 ~ p2 ~ p3 =>
      TimeOfDay(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TimeOfDay, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TimeOfDay, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) })

  }

  trait Default_TodayFormat extends scalaxb.ElemNameParser[Today] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Today")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Today] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ^^
      { case p1 ~ p2 ~ p3 =>
      Today(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Today, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Today, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) })

  }

  trait Default_NowFormat extends scalaxb.ElemNameParser[Now] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Now")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Now] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ^^
      { case p1 ~ p2 ~ p3 =>
      Now(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Now, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Now, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) })

  }

  trait Default_DateFormat extends scalaxb.ElemNameParser[Date] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Date")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Date] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "year")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "month")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "day")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Date(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Date, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Date, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.year, Some("urn:hl7-org:elm:r1"), Some("year"), __scope, false),
        __obj.month map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("month"), __scope, false) } getOrElse {Nil},
        __obj.day map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("day"), __scope, false) } getOrElse {Nil})

  }

  trait Default_DateTimeFormat extends scalaxb.ElemNameParser[DateTime] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("DateTime")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[DateTime] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "year")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "month")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "day")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "hour")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "minute")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "second")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "millisecond")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "timezoneOffset")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 =>
      DateTime(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p10.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p11.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: DateTime, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: DateTime, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.year, Some("urn:hl7-org:elm:r1"), Some("year"), __scope, false),
        __obj.month map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("month"), __scope, false) } getOrElse {Nil},
        __obj.day map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("day"), __scope, false) } getOrElse {Nil},
        __obj.hour map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("hour"), __scope, false) } getOrElse {Nil},
        __obj.minute map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("minute"), __scope, false) } getOrElse {Nil},
        __obj.second map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("second"), __scope, false) } getOrElse {Nil},
        __obj.millisecond map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("millisecond"), __scope, false) } getOrElse {Nil},
        __obj.timezoneOffset map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("timezoneOffset"), __scope, false) } getOrElse {Nil})

  }

  trait Default_TimeFormat extends scalaxb.ElemNameParser[Time] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Time")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Time] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "hour")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "minute")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "second")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "millisecond")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      Time(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Time, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Time, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.hour, Some("urn:hl7-org:elm:r1"), Some("hour"), __scope, false),
        __obj.minute map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("minute"), __scope, false) } getOrElse {Nil},
        __obj.second map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("second"), __scope, false) } getOrElse {Nil},
        __obj.millisecond map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("millisecond"), __scope, false) } getOrElse {Nil})

  }

  trait Default_SameAsFormat extends scalaxb.ElemNameParser[SameAs] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("SameAs")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SameAs] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      SameAs(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SameAs, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SameAs, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_SameOrBeforeFormat extends scalaxb.ElemNameParser[SameOrBefore] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("SameOrBefore")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SameOrBefore] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      SameOrBefore(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SameOrBefore, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SameOrBefore, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_SameOrAfterFormat extends scalaxb.ElemNameParser[SameOrAfter] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("SameOrAfter")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SameOrAfter] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      SameOrAfter(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SameOrAfter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SameOrAfter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_PointFromFormat extends scalaxb.ElemNameParser[PointFrom] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("PointFrom")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[PointFrom] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      PointFrom(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: PointFrom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: PointFrom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_WidthFormat extends scalaxb.ElemNameParser[Width] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Width")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Width] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Width(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Width, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Width, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_SizeFormat extends scalaxb.ElemNameParser[Size] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Size")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Size] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Size(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Size, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Size, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_StartFormat extends scalaxb.ElemNameParser[Start] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Start")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Start] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Start(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Start, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Start, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_EndFormat extends scalaxb.ElemNameParser[End] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("End")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[End] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      End(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: End, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: End, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_ContainsFormat extends scalaxb.ElemNameParser[Contains] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Contains")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Contains] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Contains(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Contains, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Contains, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ProperContainsFormat extends scalaxb.ElemNameParser[ProperContains] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ProperContains")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ProperContains] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ProperContains(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ProperContains, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ProperContains, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_InFormat extends scalaxb.ElemNameParser[In] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("In")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[In] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      In(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: In, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: In, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ProperInFormat extends scalaxb.ElemNameParser[ProperIn] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ProperIn")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ProperIn] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ProperIn(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ProperIn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ProperIn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_IncludesTypeFormat extends scalaxb.ElemNameParser[IncludesType] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Includes")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IncludesType] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IncludesType(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IncludesType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IncludesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_IncludedInFormat extends scalaxb.ElemNameParser[IncludedIn] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("IncludedIn")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IncludedIn] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      IncludedIn(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IncludedIn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IncludedIn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ProperIncludesFormat extends scalaxb.ElemNameParser[ProperIncludes] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ProperIncludes")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ProperIncludes] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ProperIncludes(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ProperIncludes, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ProperIncludes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ProperIncludedInFormat extends scalaxb.ElemNameParser[ProperIncludedIn] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ProperIncludedIn")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ProperIncludedIn] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ProperIncludedIn(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ProperIncludedIn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ProperIncludedIn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_BeforeFormat extends scalaxb.ElemNameParser[Before] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Before")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Before] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Before(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Before, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Before, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_AfterFormat extends scalaxb.ElemNameParser[After] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("After")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[After] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      After(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: After, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: After, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_MeetsFormat extends scalaxb.ElemNameParser[Meets] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Meets")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Meets] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Meets(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Meets, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Meets, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_MeetsBeforeFormat extends scalaxb.ElemNameParser[MeetsBefore] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("MeetsBefore")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[MeetsBefore] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      MeetsBefore(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: MeetsBefore, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: MeetsBefore, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_MeetsAfterFormat extends scalaxb.ElemNameParser[MeetsAfter] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("MeetsAfter")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[MeetsAfter] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      MeetsAfter(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: MeetsAfter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: MeetsAfter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_OverlapsFormat extends scalaxb.ElemNameParser[Overlaps] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Overlaps")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Overlaps] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Overlaps(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Overlaps, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Overlaps, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_OverlapsBeforeFormat extends scalaxb.ElemNameParser[OverlapsBefore] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("OverlapsBefore")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[OverlapsBefore] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      OverlapsBefore(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: OverlapsBefore, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: OverlapsBefore, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_OverlapsAfterFormat extends scalaxb.ElemNameParser[OverlapsAfter] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("OverlapsAfter")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[OverlapsAfter] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      OverlapsAfter(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: OverlapsAfter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: OverlapsAfter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_StartsFormat extends scalaxb.ElemNameParser[Starts] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Starts")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Starts] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Starts(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Starts, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Starts, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_EndsFormat extends scalaxb.ElemNameParser[Ends] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Ends")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Ends] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Ends(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[DateTimePrecision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Ends, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Ends, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_CollapseFormat extends scalaxb.ElemNameParser[Collapse] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Collapse")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Collapse] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Collapse(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Collapse, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Collapse, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ExpandFormat extends scalaxb.ElemNameParser[Expand] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Expand")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Expand] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Expand(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Expand, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Expand, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_UnionFormat extends scalaxb.ElemNameParser[Union] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Union")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Union] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Union(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Union, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Union, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_IntersectFormat extends scalaxb.ElemNameParser[Intersect] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Intersect")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Intersect] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Intersect(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Intersect, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Intersect, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ExceptFormat extends scalaxb.ElemNameParser[Except] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Except")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Except] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Except(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Except, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Except, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_ExistsFormat extends scalaxb.ElemNameParser[Exists] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Exists")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Exists] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Exists(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Exists, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Exists, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_TimesFormat extends scalaxb.ElemNameParser[Times] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Times")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Times] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Times(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Times, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Times, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        __obj.operand flatMap { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false) })

  }

  trait Default_FilterFormat extends scalaxb.ElemNameParser[Filter] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Filter")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Filter] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "condition")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Filter(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@scope").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@scope" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Filter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@scope", _) => __obj.scope foreach { x => attr = scala.xml.Attribute(null, "scope", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Filter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false),
        scalaxb.toXML[Expression](__obj.condition, Some("urn:hl7-org:elm:r1"), Some("condition"), __scope, false))

  }

  trait Default_FirstFormat extends scalaxb.ElemNameParser[First] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("First")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[First] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      First(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@orderBy").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@orderBy" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: First, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@orderBy", _) => __obj.orderBy foreach { x => attr = scala.xml.Attribute(null, "orderBy", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: First, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_LastFormat extends scalaxb.ElemNameParser[Last] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Last")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Last] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Last(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@orderBy").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@orderBy" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Last, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@orderBy", _) => __obj.orderBy foreach { x => attr = scala.xml.Attribute(null, "orderBy", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Last, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_SliceFormat extends scalaxb.ElemNameParser[Slice] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Slice")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Slice] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "startIndex")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "endIndex")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Slice(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p6, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Slice, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Slice, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false),
        scalaxb.toXML[Expression](__obj.startIndex, Some("urn:hl7-org:elm:r1"), Some("startIndex"), __scope, false),
        scalaxb.toXML[Expression](__obj.endIndex, Some("urn:hl7-org:elm:r1"), Some("endIndex"), __scope, false))

  }

  trait Default_IndexOfFormat extends scalaxb.ElemNameParser[IndexOf] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("IndexOf")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IndexOf] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "element")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      IndexOf(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p5, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IndexOf, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IndexOf, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false),
        scalaxb.toXML[Expression](__obj.element, Some("urn:hl7-org:elm:r1"), Some("element"), __scope, false))

  }

  trait Default_FlattenFormat extends scalaxb.ElemNameParser[Flatten] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Flatten")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Flatten] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Flatten(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Flatten, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Flatten, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_SortFormat extends scalaxb.ElemNameParser[Sort] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Sort")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Sort] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "by")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Sort(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        p4 map { scalaxb.fromXML[SortByItem](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Sort, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Sort, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false),
        __obj.by flatMap { scalaxb.toXML[SortByItem](_, Some("urn:hl7-org:elm:r1"), Some("by"), __scope, false) })

  }

  trait Default_ForEachFormat extends scalaxb.ElemNameParser[ForEach] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ForEach")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ForEach] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "element")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ForEach(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@scope").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@scope" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ForEach, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@scope", _) => __obj.scope foreach { x => attr = scala.xml.Attribute(null, "scope", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ForEach, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false),
        scalaxb.toXML[Expression](__obj.element, Some("urn:hl7-org:elm:r1"), Some("element"), __scope, false))

  }

  trait Default_RepeatFormat extends scalaxb.ElemNameParser[Repeat] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Repeat")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Repeat] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "element")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Repeat(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@scope").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@scope" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Repeat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@scope", _) => __obj.scope foreach { x => attr = scala.xml.Attribute(null, "scope", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Repeat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false),
        scalaxb.toXML[Expression](__obj.element, Some("urn:hl7-org:elm:r1"), Some("element"), __scope, false))

  }

  trait Default_DistinctFormat extends scalaxb.ElemNameParser[Distinct] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Distinct")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Distinct] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Distinct(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Distinct, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Distinct, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_CurrentFormat extends scalaxb.ElemNameParser[Current] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Current")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Current] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      Current(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@scope").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@scope" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Current, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@scope", _) => __obj.scope foreach { x => attr = scala.xml.Attribute(null, "scope", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Current, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_IterationFormat extends scalaxb.ElemNameParser[Iteration] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Iteration")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Iteration] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      Iteration(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@scope").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@scope" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Iteration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@scope", _) => __obj.scope foreach { x => attr = scala.xml.Attribute(null, "scope", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Iteration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_TotalFormat extends scalaxb.ElemNameParser[Total] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Total")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Total] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      Total(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@scope").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@scope" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Total, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@scope", _) => __obj.scope foreach { x => attr = scala.xml.Attribute(null, "scope", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Total, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_SingletonFromFormat extends scalaxb.ElemNameParser[SingletonFrom] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("SingletonFrom")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SingletonFrom] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "operand")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      SingletonFrom(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SingletonFrom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SingletonFrom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.operand, Some("urn:hl7-org:elm:r1"), Some("operand"), __scope, false))

  }

  trait Default_AggregateExpressionFormat extends scalaxb.XMLFormat[AggregateExpression] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, AggregateExpression] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("AllTrue")) => Right(scalaxb.fromXML[AllTrue](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("StdDev")) => Right(scalaxb.fromXML[StdDev](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Variance")) => Right(scalaxb.fromXML[Variance](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Median")) => Right(scalaxb.fromXML[Median](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Avg")) => Right(scalaxb.fromXML[Avg](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Min")) => Right(scalaxb.fromXML[Min](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Sum")) => Right(scalaxb.fromXML[Sum](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Aggregate")) => Right(scalaxb.fromXML[Aggregate](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Count")) => Right(scalaxb.fromXML[Count](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Product")) => Right(scalaxb.fromXML[ProductType](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Max")) => Right(scalaxb.fromXML[Max](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("GeometricMean")) => Right(scalaxb.fromXML[GeometricMean](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Mode")) => Right(scalaxb.fromXML[Mode](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PopulationVariance")) => Right(scalaxb.fromXML[PopulationVariance](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("PopulationStdDev")) => Right(scalaxb.fromXML[PopulationStdDev](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("AnyTrue")) => Right(scalaxb.fromXML[AnyTrue](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: AggregateExpression, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: AllTrue => scalaxb.toXML[AllTrue](x, __namespace, __elementLabel, __scope, true)
      case x: StdDev => scalaxb.toXML[StdDev](x, __namespace, __elementLabel, __scope, true)
      case x: Variance => scalaxb.toXML[Variance](x, __namespace, __elementLabel, __scope, true)
      case x: Median => scalaxb.toXML[Median](x, __namespace, __elementLabel, __scope, true)
      case x: Avg => scalaxb.toXML[Avg](x, __namespace, __elementLabel, __scope, true)
      case x: Min => scalaxb.toXML[Min](x, __namespace, __elementLabel, __scope, true)
      case x: Sum => scalaxb.toXML[Sum](x, __namespace, __elementLabel, __scope, true)
      case x: Aggregate => scalaxb.toXML[Aggregate](x, __namespace, __elementLabel, __scope, true)
      case x: Count => scalaxb.toXML[Count](x, __namespace, __elementLabel, __scope, true)
      case x: ProductType => scalaxb.toXML[ProductType](x, __namespace, __elementLabel, __scope, true)
      case x: Max => scalaxb.toXML[Max](x, __namespace, __elementLabel, __scope, true)
      case x: GeometricMean => scalaxb.toXML[GeometricMean](x, __namespace, __elementLabel, __scope, true)
      case x: Mode => scalaxb.toXML[Mode](x, __namespace, __elementLabel, __scope, true)
      case x: PopulationVariance => scalaxb.toXML[PopulationVariance](x, __namespace, __elementLabel, __scope, true)
      case x: PopulationStdDev => scalaxb.toXML[PopulationStdDev](x, __namespace, __elementLabel, __scope, true)
      case x: AnyTrue => scalaxb.toXML[AnyTrue](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_AggregateFormat extends scalaxb.ElemNameParser[Aggregate] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Aggregate")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Aggregate] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "iteration")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "initialValue")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      Aggregate(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p5, scalaxb.ElemName(node) :: stack),
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Aggregate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Aggregate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false),
        scalaxb.toXML[Expression](__obj.iteration, Some("urn:hl7-org:elm:r1"), Some("iteration"), __scope, false),
        __obj.initialValue map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("initialValue"), __scope, false) } getOrElse {Nil})

  }

  trait Default_CountFormat extends scalaxb.ElemNameParser[Count] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Count")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Count] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Count(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Count, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Count, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_SumFormat extends scalaxb.ElemNameParser[Sum] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Sum")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Sum] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Sum(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Sum, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Sum, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_ProductTypeFormat extends scalaxb.ElemNameParser[ProductType] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Product")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ProductType] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ProductType(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ProductType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ProductType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_MinFormat extends scalaxb.ElemNameParser[Min] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Min")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Min] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Min(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Min, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Min, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_MaxFormat extends scalaxb.ElemNameParser[Max] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Max")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Max] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Max(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Max, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Max, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_AvgFormat extends scalaxb.ElemNameParser[Avg] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Avg")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Avg] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Avg(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Avg, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Avg, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_GeometricMeanFormat extends scalaxb.ElemNameParser[GeometricMean] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("GeometricMean")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[GeometricMean] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      GeometricMean(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: GeometricMean, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: GeometricMean, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_MedianFormat extends scalaxb.ElemNameParser[Median] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Median")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Median] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Median(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Median, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Median, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_ModeFormat extends scalaxb.ElemNameParser[Mode] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Mode")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Mode] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Mode(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Mode, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Mode, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_VarianceFormat extends scalaxb.ElemNameParser[Variance] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Variance")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Variance] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Variance(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Variance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Variance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_PopulationVarianceFormat extends scalaxb.ElemNameParser[PopulationVariance] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("PopulationVariance")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[PopulationVariance] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      PopulationVariance(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: PopulationVariance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: PopulationVariance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_StdDevFormat extends scalaxb.ElemNameParser[StdDev] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("StdDev")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[StdDev] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      StdDev(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: StdDev, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: StdDev, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_PopulationStdDevFormat extends scalaxb.ElemNameParser[PopulationStdDev] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("PopulationStdDev")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[PopulationStdDev] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      PopulationStdDev(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: PopulationStdDev, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: PopulationStdDev, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_AllTrueFormat extends scalaxb.ElemNameParser[AllTrue] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("AllTrue")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[AllTrue] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      AllTrue(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AllTrue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AllTrue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_AnyTrueFormat extends scalaxb.ElemNameParser[AnyTrue] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("AnyTrue")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[AnyTrue] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      AnyTrue(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AnyTrue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AnyTrue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_PropertyableFormat extends scalaxb.XMLFormat[Propertyable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, Propertyable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("Search")) => Right(scalaxb.fromXML[Search](node, stack))
          case _ => Right(scalaxb.fromXML[Property](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: Propertyable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: Search => scalaxb.toXML[Search](x, __namespace, __elementLabel, __scope, true)
      case x: Property => scalaxb.toXML[Property](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_PropertyFormat extends scalaxb.ElemNameParser[Property] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Property")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Property] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 =>
      Property(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ },
        (node \ "@scope").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@scope" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Property, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@path", _) => attr = scala.xml.Attribute(null, "path", __obj.path.toString, attr)
        case ("@scope", _) => __obj.scope foreach { x => attr = scala.xml.Attribute(null, "scope", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Property, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.source map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AliasedQuerySourcableFormat extends scalaxb.XMLFormat[AliasedQuerySourcable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, AliasedQuerySourcable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("RelationshipClause")) => Right(scalaxb.fromXML[RelationshipClause](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("With")) => Right(scalaxb.fromXML[With](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Without")) => Right(scalaxb.fromXML[Without](node, stack))
          case _ => Right(scalaxb.fromXML[AliasedQuerySource](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: AliasedQuerySourcable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: RelationshipClause => scalaxb.toXML[RelationshipClause](x, __namespace, __elementLabel, __scope, true)
      case x: AliasedQuerySource => scalaxb.toXML[AliasedQuerySource](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait Default_AliasedQuerySourceFormat extends scalaxb.ElemNameParser[AliasedQuerySource] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("AliasedQuerySource")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[AliasedQuerySource] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "expression")) ^^
      { case p1 ~ p2 ~ p3 =>
      AliasedQuerySource(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@alias").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@alias" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AliasedQuerySource, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@alias", _) => attr = scala.xml.Attribute(null, "alias", __obj.alias.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AliasedQuerySource, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.expression, Some("urn:hl7-org:elm:r1"), Some("expression"), __scope, false))

  }

  trait Default_LetClauseFormat extends scalaxb.ElemNameParser[LetClause] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("LetClause")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[LetClause] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "expression")) ^^
      { case p1 ~ p2 ~ p3 =>
      LetClause(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@identifier").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@identifier" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: LetClause, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@identifier", _) => attr = scala.xml.Attribute(null, "identifier", __obj.identifier.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: LetClause, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.expression, Some("urn:hl7-org:elm:r1"), Some("expression"), __scope, false))

  }

  trait Default_RelationshipClauseFormat extends scalaxb.XMLFormat[RelationshipClause] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, RelationshipClause] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("With")) => Right(scalaxb.fromXML[With](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("Without")) => Right(scalaxb.fromXML[Without](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: RelationshipClause, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: With => scalaxb.toXML[With](x, __namespace, __elementLabel, __scope, true)
      case x: Without => scalaxb.toXML[Without](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_WithFormat extends scalaxb.ElemNameParser[With] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("With")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[With] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "expression")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "suchThat")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      With(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@alias").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@alias" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: With, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@alias", _) => attr = scala.xml.Attribute(null, "alias", __obj.alias.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: With, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.expression, Some("urn:hl7-org:elm:r1"), Some("expression"), __scope, false),
        scalaxb.toXML[Expression](__obj.suchThat, Some("urn:hl7-org:elm:r1"), Some("suchThat"), __scope, false))

  }

  trait Default_WithoutFormat extends scalaxb.ElemNameParser[Without] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Without")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Without] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "expression")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "suchThat")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Without(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@alias").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@alias" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Without, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@alias", _) => attr = scala.xml.Attribute(null, "alias", __obj.alias.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Without, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.expression, Some("urn:hl7-org:elm:r1"), Some("expression"), __scope, false),
        scalaxb.toXML[Expression](__obj.suchThat, Some("urn:hl7-org:elm:r1"), Some("suchThat"), __scope, false))

  }

  def build_SortDirectionFormat = new Default_SortDirectionFormat {}
  trait Default_SortDirectionFormat extends scalaxb.XMLFormat[SortDirection] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): SortDirection =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, SortDirection] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("asc")) => Asc
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ascending")) => Ascending
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("desc")) => Desc
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("descending")) => Descending

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, SortDirection] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: SortDirection, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_SortByItemFormat extends scalaxb.XMLFormat[SortByItem] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, SortByItem] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm:r1"), Some("ByExpression")) => Right(scalaxb.fromXML[ByExpression](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ByDirection")) => Right(scalaxb.fromXML[ByDirection](node, stack))
          case (Some("urn:hl7-org:elm:r1"), Some("ByColumn")) => Right(scalaxb.fromXML[ByColumn](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: SortByItem, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: ByExpression => scalaxb.toXML[ByExpression](x, __namespace, __elementLabel, __scope, true)
      case x: ByDirection => scalaxb.toXML[ByDirection](x, __namespace, __elementLabel, __scope, true)
      case x: ByColumn => scalaxb.toXML[ByColumn](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_ByDirectionFormat extends scalaxb.ElemNameParser[ByDirection] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ByDirection")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ByDirection] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ByDirection(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@direction").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[SortDirection](x, scalaxb.ElemName(node) :: stack)) } map { "@direction" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ByDirection, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@direction", _) => __obj.direction foreach { x => attr = scala.xml.Attribute(null, "direction", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ByDirection, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ByColumnFormat extends scalaxb.ElemNameParser[ByColumn] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ByColumn")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ByColumn] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ByColumn(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@direction").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[SortDirection](x, scalaxb.ElemName(node) :: stack)) } map { "@direction" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ByColumn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@direction", _) => __obj.direction foreach { x => attr = scala.xml.Attribute(null, "direction", x.toString, attr) }
        case ("@path", _) => __obj.path foreach { x => attr = scala.xml.Attribute(null, "path", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ByColumn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ByExpressionFormat extends scalaxb.ElemNameParser[ByExpression] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ByExpression")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ByExpression] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "expression")) ^^
      { case p1 ~ p2 ~ p3 =>
      ByExpression(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@direction").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[SortDirection](x, scalaxb.ElemName(node) :: stack)) } map { "@direction" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ByExpression, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@direction", _) => __obj.direction foreach { x => attr = scala.xml.Attribute(null, "direction", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ByExpression, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.expression, Some("urn:hl7-org:elm:r1"), Some("expression"), __scope, false))

  }

  trait Default_SortClauseFormat extends scalaxb.ElemNameParser[SortClause] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("SortClause")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SortClause] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "by")) ^^
      { case p1 ~ p2 ~ p3 =>
      SortClause(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[SortByItem](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SortClause, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SortClause, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.by flatMap { scalaxb.toXML[SortByItem](_, Some("urn:hl7-org:elm:r1"), Some("by"), __scope, false) })

  }

  trait Default_ReturnClauseFormat extends scalaxb.ElemNameParser[ReturnClause] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("ReturnClause")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ReturnClause] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "expression")) ^^
      { case p1 ~ p2 ~ p3 =>
      ReturnClause(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@distinct").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack))) map { "@distinct" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ReturnClause, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@distinct", _) => if (__obj.distinct.toString != "true") attr = scala.xml.Attribute(null, "distinct", __obj.distinct.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ReturnClause, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.expression, Some("urn:hl7-org:elm:r1"), Some("expression"), __scope, false))

  }

  trait Default_AggregateClauseFormat extends scalaxb.ElemNameParser[AggregateClause] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("AggregateClause")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[AggregateClause] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "expression")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "starting")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      AggregateClause(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p3, scalaxb.ElemName(node) :: stack),
        p4.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@identifier").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@identifier" -> _ },
        (node \ "@distinct").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@distinct" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AggregateClause, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@identifier", _) => attr = scala.xml.Attribute(null, "identifier", __obj.identifier.toString, attr)
        case ("@distinct", _) => if (__obj.distinct.toString != "false") attr = scala.xml.Attribute(null, "distinct", __obj.distinct.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AggregateClause, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[Expression](__obj.expression, Some("urn:hl7-org:elm:r1"), Some("expression"), __scope, false),
        __obj.starting map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("starting"), __scope, false) } getOrElse {Nil})

  }

  trait Default_QueryFormat extends scalaxb.ElemNameParser[Query] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Query")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Query] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "let")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "relationship")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "where")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "return")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "aggregate")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "sort")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      Query(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[AliasedQuerySourcable](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[LetClause](_, scalaxb.ElemName(node) :: stack) },
        p5 map { scalaxb.fromXML[RelationshipClause](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[ReturnClause](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[AggregateClause](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[SortClause](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Query, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Query, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.source flatMap { scalaxb.toXML[AliasedQuerySourcable](_, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false) },
        __obj.let flatMap { scalaxb.toXML[LetClause](_, Some("urn:hl7-org:elm:r1"), Some("let"), __scope, false) },
        __obj.relationship flatMap { scalaxb.toXML[RelationshipClause](_, Some("urn:hl7-org:elm:r1"), Some("relationship"), __scope, false) },
        __obj.where map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("where"), __scope, false) } getOrElse {Nil},
        __obj.returnValue map { scalaxb.toXML[ReturnClause](_, Some("urn:hl7-org:elm:r1"), Some("return"), __scope, false) } getOrElse {Nil},
        __obj.aggregate map { scalaxb.toXML[AggregateClause](_, Some("urn:hl7-org:elm:r1"), Some("aggregate"), __scope, false) } getOrElse {Nil},
        __obj.sort map { scalaxb.toXML[SortClause](_, Some("urn:hl7-org:elm:r1"), Some("sort"), __scope, false) } getOrElse {Nil})

  }

  trait Default_AliasRefFormat extends scalaxb.ElemNameParser[AliasRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("AliasRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[AliasRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      AliasRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: AliasRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: AliasRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_QueryLetRefFormat extends scalaxb.ElemNameParser[QueryLetRef] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("QueryLetRef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[QueryLetRef] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      QueryLetRef(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: QueryLetRef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: QueryLetRef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ChildrenFormat extends scalaxb.ElemNameParser[Children] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Children")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Children] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Children(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Children, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Children, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_DescendentsFormat extends scalaxb.ElemNameParser[Descendents] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Descendents")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Descendents] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      Descendents(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Descendents, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Descendents, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false))

  }

  trait Default_MessageFormat extends scalaxb.ElemNameParser[Message] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm:r1")
    
    override def typeName: Option[String] = Some("Message")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Message] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "resultTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "signature")) ~ 
      (scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "source")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "condition")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "code")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "severity")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm:r1"), "message")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      Message(p1 map { scalaxb.fromXML[CqlToElmBase](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[Expression](p4, scalaxb.ElemName(node) :: stack),
        p5.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[Expression](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@localId").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@localId" -> _ },
        (node \ "@locator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@locator" -> _ },
        (node \ "@resultTypeName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.namespace.QName](x, scalaxb.ElemName(node) :: stack)(scalaxb.XMLStandardTypes.qnameXMLFormat(node.scope))) } map { "@resultTypeName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: Message, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@localId", _) => __obj.localId foreach { x => attr = scala.xml.Attribute(null, "localId", x.toString, attr) }
        case ("@locator", _) => __obj.locator foreach { x => attr = scala.xml.Attribute(null, "locator", x.toString, attr) }
        case ("@resultTypeName", _) => __obj.resultTypeName foreach { x => attr = scala.xml.Attribute(null, "resultTypeName", scalaxb.Helper.toString(x, __scope), attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: Message, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[CqlToElmBase](_, Some("urn:hl7-org:elm:r1"), Some("annotation"), __scope, false) },
        __obj.resultTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("resultTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.signature flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm:r1"), Some("signature"), __scope, false) },
        scalaxb.toXML[Expression](__obj.source, Some("urn:hl7-org:elm:r1"), Some("source"), __scope, false),
        __obj.condition map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("condition"), __scope, false) } getOrElse {Nil},
        __obj.code map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("code"), __scope, false) } getOrElse {Nil},
        __obj.severity map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("severity"), __scope, false) } getOrElse {Nil},
        __obj.message map { scalaxb.toXML[Expression](_, Some("urn:hl7-org:elm:r1"), Some("message"), __scope, false) } getOrElse {Nil})

  }


}

