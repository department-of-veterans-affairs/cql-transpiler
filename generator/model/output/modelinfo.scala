// Generated by <a href="http://scalaxb.org/">scalaxb</a>.


/** Defines an available context type for the model.
*/
case class ContextInfo(contextType: NamedTypeSpecifier,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes("@name").as[String]
  lazy val keyElement = attributes.get("@keyElement") map { _.as[String]}
  lazy val birthDateElement = attributes.get("@birthDateElement") map { _.as[String]}
}

      
      


/** Defines the relationship of a class to the context.
*/
case class RelationshipInfo(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val context = attributes("@context").as[String]
  lazy val relatedKeyElement = attributes.get("@relatedKeyElement") map { _.as[String]}
}

      
      


/** Defines a possible search path for a ClassInfo within the model.
*/
case class SearchInfo(typeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes("@name").as[String]
  lazy val path = attributes("@path").as[String]
  lazy val typeValue = attributes.get("@type") map { _.as[String]}
  lazy val label = attributes.get("@label") map { _.as[String]}
  lazy val description = attributes.get("@description") map { _.as[String]}
  lazy val definition = attributes.get("@definition") map { _.as[String]}
  lazy val comment = attributes.get("@comment") map { _.as[String]}
}

      
      


/** The ModelInfo type defines the metadata associated with a particular model to enable it to be used by the CQL translator. Note that none of the information specified here is required, it just enables some convenient shorthands within the language.
*/
case class ModelInfo(requiredModelInfo: Seq[ModelSpecifier] = Nil,
  typeInfo: Seq[TypeInfo] = Nil,
  conversionInfo: Seq[ConversionInfo] = Nil,
  contextInfo: Seq[ContextInfo] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes("@name").as[String]
  lazy val version = attributes.get("@version") map { _.as[String]}
  lazy val url = attributes("@url").as[java.net.URI]
  lazy val targetUrl = attributes.get("@targetUrl") map { _.as[java.net.URI]}
  lazy val targetVersion = attributes.get("@targetVersion") map { _.as[String]}
  lazy val schemaLocation = attributes.get("@schemaLocation") map { _.as[String]}
  lazy val targetQualifier = attributes.get("@targetQualifier") map { _.as[String]}
  lazy val patientClassName = attributes.get("@patientClassName") map { _.as[String]}
  lazy val patientClassIdentifier = attributes.get("@patientClassIdentifier") map { _.as[String]}
  lazy val patientBirthDatePropertyName = attributes.get("@patientBirthDatePropertyName") map { _.as[String]}
  lazy val caseSensitive = attributes.get("@caseSensitive") map { _.as[Boolean]}
  lazy val strictRetrieveTyping = attributes.get("@strictRetrieveTyping") map { _.as[Boolean]}
  lazy val defaultContext = attributes.get("@defaultContext") map { _.as[String]}
}

      
      

sealed trait BindingStrength

object BindingStrength {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[BindingStrength]): BindingStrength = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: BindingStrength) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[BindingStrength] = Seq(Required, Extensible, Preferred, Example)
}

case object Required extends BindingStrength { override def toString = "Required" }
case object Extensible extends BindingStrength { override def toString = "Extensible" }
case object Preferred extends BindingStrength { override def toString = "Preferred" }
case object Example extends BindingStrength { override def toString = "Example" }


/** Specifies binding information for an element
*/
case class BindingInfo(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes.get("@name") map { _.as[String]}
  lazy val description = attributes.get("@description") map { _.as[String]}
  lazy val strength = attributes("@strength").as[BindingStrength]
  lazy val valueSet = attributes("@valueSet").as[java.net.URI]
}

      
      


case class ClassInfoElement(typeSpecifier: Option[TypeSpecifier] = None,
  elementTypeSpecifier: Option[TypeSpecifier] = None,
  binding: Option[BindingInfo] = None,
  constraint: Seq[ConstraintInfo] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes("@name").as[String]
  lazy val typeValue = attributes.get("@type") map { _.as[String]}
  lazy val elementType = attributes.get("@elementType") map { _.as[String]}
  lazy val prohibited = attributes.get("@prohibited") map { _.as[Boolean]}
  lazy val oneBased = attributes.get("@oneBased") map { _.as[Boolean]}
  lazy val target = attributes.get("@target") map { _.as[String]}
  lazy val label = attributes.get("@label") map { _.as[String]}
  lazy val description = attributes.get("@description") map { _.as[String]}
  lazy val definition = attributes.get("@definition") map { _.as[String]}
  lazy val comment = attributes.get("@comment") map { _.as[String]}
  lazy val min = attributes.get("@min") map { _.as[Int]}
  lazy val max = attributes.get("@max") map { _.as[String]}
  lazy val mustSupport = attributes.get("@mustSupport") map { _.as[Boolean]}
}

      
      


/** The ExpressionInfo type models an expression in some language.
*/
case class ExpressionInfo(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val language = attributes("@language").as[String]
  lazy val expression = attributes("@expression").as[String]
}

      
      


/** The ConstraintInfo type models the definition of a constraint which can then be associated with a class info, class info element, or other model element.
*/
case class ConstraintInfo(expression: Seq[ExpressionInfo] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes("@name").as[String]
  lazy val severity = attributes("@severity").as[String]
  lazy val description = attributes.get("@description") map { _.as[String]}
  lazy val message = attributes.get("@message") map { _.as[String]}
}

      
      


/** The ClassInfo type models information associated with a single class in the data model.
*/
trait ClassInfoable extends TypeInfo {
  def baseTypeSpecifier: Option[TypeSpecifier]
  def parameter: Seq[TypeParameterInfo]
  def element: Seq[ClassInfoElement]
  def contextRelationship: Seq[RelationshipInfo]
  def targetContextRelationship: Seq[RelationshipInfo]
  def search: Seq[SearchInfo]
  def inferenceExpression: Seq[ExpressionInfo]
  def constraint: Seq[ConstraintInfo]
  def baseType: Option[String]
  def namespace: Option[String]
  def name: String
  def identifier: Option[String]
  def label: Option[String]
  def description: Option[String]
  def definition: Option[String]
  def comment: Option[String]
  def target: Option[String]
  def retrievable: Boolean
  def primaryCodePath: Option[String]
  def primaryValueSetPath: Option[String]
}


/** The ClassInfo type models information associated with a single class in the data model.
*/
case class ClassInfo(baseTypeSpecifier: Option[TypeSpecifier] = None,
  parameter: Seq[TypeParameterInfo] = Nil,
  element: Seq[ClassInfoElement] = Nil,
  contextRelationship: Seq[RelationshipInfo] = Nil,
  targetContextRelationship: Seq[RelationshipInfo] = Nil,
  search: Seq[SearchInfo] = Nil,
  inferenceExpression: Seq[ExpressionInfo] = Nil,
  constraint: Seq[ConstraintInfo] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends ClassInfoable {
  lazy val baseType = attributes.get("@baseType") map { _.as[String]}
  lazy val namespace = attributes.get("@namespace") map { _.as[String]}
  lazy val name = attributes("@name").as[String]
  lazy val identifier = attributes.get("@identifier") map { _.as[String]}
  lazy val label = attributes.get("@label") map { _.as[String]}
  lazy val description = attributes.get("@description") map { _.as[String]}
  lazy val definition = attributes.get("@definition") map { _.as[String]}
  lazy val comment = attributes.get("@comment") map { _.as[String]}
  lazy val target = attributes.get("@target") map { _.as[String]}
  lazy val retrievable = attributes("@retrievable").as[Boolean]
  lazy val primaryCodePath = attributes.get("@primaryCodePath") map { _.as[String]}
  lazy val primaryValueSetPath = attributes.get("@primaryValueSetPath") map { _.as[String]}
}

      
      


trait TypeInfo {
  def baseTypeSpecifier: Option[TypeSpecifier]
  def baseType: Option[String]
}


case class SimpleTypeInfo(baseTypeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeInfo {
  lazy val baseType = attributes.get("@baseType") map { _.as[String]}
  lazy val namespace = attributes.get("@namespace") map { _.as[String]}
  lazy val name = attributes("@name").as[String]
  lazy val target = attributes.get("@target") map { _.as[String]}
}

      
      


case class IntervalTypeInfo(baseTypeSpecifier: Option[TypeSpecifier] = None,
  pointTypeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeInfo {
  lazy val baseType = attributes.get("@baseType") map { _.as[String]}
  lazy val pointType = attributes.get("@pointType") map { _.as[String]}
}

      
      


case class ListTypeInfo(baseTypeSpecifier: Option[TypeSpecifier] = None,
  elementTypeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeInfo {
  lazy val baseType = attributes.get("@baseType") map { _.as[String]}
  lazy val elementType = attributes.get("@elementType") map { _.as[String]}
}

      
      


case class TupleTypeInfoElement(typeSpecifier: Option[TypeSpecifier] = None,
  elementTypeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes("@name").as[String]
  lazy val typeValue = attributes.get("@type") map { _.as[String]}
  lazy val elementType = attributes.get("@elementType") map { _.as[String]}
  lazy val prohibited = attributes.get("@prohibited") map { _.as[Boolean]}
  lazy val oneBased = attributes.get("@oneBased") map { _.as[Boolean]}
}

      
      


case class TupleTypeInfo(baseTypeSpecifier: Option[TypeSpecifier] = None,
  element: Seq[TupleTypeInfoElement] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeInfo {
  lazy val baseType = attributes.get("@baseType") map { _.as[String]}
}

      
      


case class ProfileInfo(baseTypeSpecifier: Option[TypeSpecifier] = None,
  parameter: Seq[TypeParameterInfo] = Nil,
  element: Seq[ClassInfoElement] = Nil,
  contextRelationship: Seq[RelationshipInfo] = Nil,
  targetContextRelationship: Seq[RelationshipInfo] = Nil,
  search: Seq[SearchInfo] = Nil,
  inferenceExpression: Seq[ExpressionInfo] = Nil,
  constraint: Seq[ConstraintInfo] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends ClassInfoable {
  lazy val baseType = attributes.get("@baseType") map { _.as[String]}
  lazy val namespace = attributes.get("@namespace") map { _.as[String]}
  lazy val name = attributes("@name").as[String]
  lazy val identifier = attributes.get("@identifier") map { _.as[String]}
  lazy val label = attributes.get("@label") map { _.as[String]}
  lazy val description = attributes.get("@description") map { _.as[String]}
  lazy val definition = attributes.get("@definition") map { _.as[String]}
  lazy val comment = attributes.get("@comment") map { _.as[String]}
  lazy val target = attributes.get("@target") map { _.as[String]}
  lazy val retrievable = attributes("@retrievable").as[Boolean]
  lazy val primaryCodePath = attributes.get("@primaryCodePath") map { _.as[String]}
  lazy val primaryValueSetPath = attributes.get("@primaryValueSetPath") map { _.as[String]}
}

      
      


case class ConversionInfo(fromTypeSpecifier: Option[TypeSpecifier] = None,
  toTypeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val functionName = attributes("@functionName").as[String]
  lazy val fromType = attributes.get("@fromType") map { _.as[String]}
  lazy val toType = attributes.get("@toType") map { _.as[String]}
}

      
      


case class ChoiceTypeInfo(baseTypeSpecifier: Option[TypeSpecifier] = None,
  typeValue: Seq[TypeSpecifier] = Nil,
  choice: Seq[TypeSpecifier] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeInfo {
  lazy val baseType = attributes.get("@baseType") map { _.as[String]}
}

      
      


case class ModelSpecifier(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val url = attributes.get("@url") map { _.as[java.net.URI]}
  lazy val name = attributes("@name").as[String]
  lazy val version = attributes.get("@version") map { _.as[String]}
}

      
      


trait TypeSpecifier {
  
}


case class NamedTypeSpecifier(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeSpecifier {
  lazy val modelName = attributes.get("@modelName") map { _.as[String]}
  lazy val namespace = attributes.get("@namespace") map { _.as[String]}
  lazy val name = attributes("@name").as[String]
}

      
      


case class ListTypeSpecifier(elementTypeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeSpecifier {
  lazy val elementType = attributes.get("@elementType") map { _.as[String]}
}

      
      


case class IntervalTypeSpecifier(pointTypeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeSpecifier {
  lazy val pointType = attributes.get("@pointType") map { _.as[String]}
}

      
      


case class ChoiceTypeSpecifier(choice: Seq[TypeSpecifier] = Nil) extends TypeSpecifier
      
      


/** A type which is generic class parameter such as T in MyGeneric<T extends
            SomeType>.
        
*/
case class ParameterTypeSpecifier(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeSpecifier {
  lazy val parameterName = attributes("@parameterName").as[String]
}

      
      


/** A type which is replacing a class parameter such as T in MyClass extends MyGeneric<AValidType>.
*/
case class BoundParameterTypeSpecifier(elementTypeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TypeSpecifier {
  lazy val parameterName = attributes("@parameterName").as[String]
  lazy val boundType = attributes("@boundType").as[String]
}

      
      


/** A generic class parameter such as T in MyGeneric<T extends SomeType>.
        
*/
case class TypeParameterInfo(typeSpecifier: Option[TypeSpecifier] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes("@name").as[String]
  lazy val constraint = attributes("@constraint").as[String]
  lazy val constraintType = attributes.get("@constraintType") map { _.as[String]}
}

      
      


/** TupleTypeSpecifierElement defines the name and type of a single element within a TupleTypeSpecifier.
*/
case class TupleTypeSpecifierElement(elementType: TypeSpecifier,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes("@name").as[String]
}

      
      


/** TupleTypeSpecifier defines the possible elements of a tuple.
*/
case class TupleTypeSpecifier(element: Seq[TupleTypeSpecifierElement] = Nil) extends TypeSpecifier
      
      

