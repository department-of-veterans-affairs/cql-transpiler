// Generated by <a href="http://scalaxb.org/">scalaxb</a>.

import scala.concurrent.{ Future, ExecutionContext }


/**
usage:
val obj = scalaxb.fromXML[.Foo](node)
val document = scalaxb.toXML[.Foo](obj, "foo", .defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(None -> "urn:hl7-org:elm-modelinfo:r1",
    Some("tns") -> "urn:hl7-org:elm-modelinfo:r1",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val _ContextInfoFormat: scalaxb.XMLFormat[ContextInfo] = new Default_ContextInfoFormat {}
  implicit lazy val _RelationshipInfoFormat: scalaxb.XMLFormat[RelationshipInfo] = new Default_RelationshipInfoFormat {}
  implicit lazy val _SearchInfoFormat: scalaxb.XMLFormat[SearchInfo] = new Default_SearchInfoFormat {}
  implicit lazy val _ModelInfoFormat: scalaxb.XMLFormat[ModelInfo] = new Default_ModelInfoFormat {}
  implicit lazy val _BindingStrengthFormat: scalaxb.XMLFormat[BindingStrength] = new Default_BindingStrengthFormat {}
  implicit lazy val _BindingInfoFormat: scalaxb.XMLFormat[BindingInfo] = new Default_BindingInfoFormat {}
  implicit lazy val _ClassInfoElementFormat: scalaxb.XMLFormat[ClassInfoElement] = new Default_ClassInfoElementFormat {}
  implicit lazy val _ExpressionInfoFormat: scalaxb.XMLFormat[ExpressionInfo] = new Default_ExpressionInfoFormat {}
  implicit lazy val _ConstraintInfoFormat: scalaxb.XMLFormat[ConstraintInfo] = new Default_ConstraintInfoFormat {}
  implicit lazy val _ClassInfoableFormat: scalaxb.XMLFormat[ClassInfoable] = new Default_ClassInfoableFormat {}
  implicit lazy val _ClassInfoFormat: scalaxb.XMLFormat[ClassInfo] = new Default_ClassInfoFormat {}
  implicit lazy val _TypeInfoFormat: scalaxb.XMLFormat[TypeInfo] = new Default_TypeInfoFormat {}
  implicit lazy val _SimpleTypeInfoFormat: scalaxb.XMLFormat[SimpleTypeInfo] = new Default_SimpleTypeInfoFormat {}
  implicit lazy val _IntervalTypeInfoFormat: scalaxb.XMLFormat[IntervalTypeInfo] = new Default_IntervalTypeInfoFormat {}
  implicit lazy val _ListTypeInfoFormat: scalaxb.XMLFormat[ListTypeInfo] = new Default_ListTypeInfoFormat {}
  implicit lazy val _TupleTypeInfoElementFormat: scalaxb.XMLFormat[TupleTypeInfoElement] = new Default_TupleTypeInfoElementFormat {}
  implicit lazy val _TupleTypeInfoFormat: scalaxb.XMLFormat[TupleTypeInfo] = new Default_TupleTypeInfoFormat {}
  implicit lazy val _ProfileInfoFormat: scalaxb.XMLFormat[ProfileInfo] = new Default_ProfileInfoFormat {}
  implicit lazy val _ConversionInfoFormat: scalaxb.XMLFormat[ConversionInfo] = new Default_ConversionInfoFormat {}
  implicit lazy val _ChoiceTypeInfoFormat: scalaxb.XMLFormat[ChoiceTypeInfo] = new Default_ChoiceTypeInfoFormat {}
  implicit lazy val _ModelSpecifierFormat: scalaxb.XMLFormat[ModelSpecifier] = new Default_ModelSpecifierFormat {}
  implicit lazy val _TypeSpecifierFormat: scalaxb.XMLFormat[TypeSpecifier] = new Default_TypeSpecifierFormat {}
  implicit lazy val _NamedTypeSpecifierFormat: scalaxb.XMLFormat[NamedTypeSpecifier] = new Default_NamedTypeSpecifierFormat {}
  implicit lazy val _ListTypeSpecifierFormat: scalaxb.XMLFormat[ListTypeSpecifier] = new Default_ListTypeSpecifierFormat {}
  implicit lazy val _IntervalTypeSpecifierFormat: scalaxb.XMLFormat[IntervalTypeSpecifier] = new Default_IntervalTypeSpecifierFormat {}
  implicit lazy val _ChoiceTypeSpecifierFormat: scalaxb.XMLFormat[ChoiceTypeSpecifier] = new Default_ChoiceTypeSpecifierFormat {}
  implicit lazy val _ParameterTypeSpecifierFormat: scalaxb.XMLFormat[ParameterTypeSpecifier] = new Default_ParameterTypeSpecifierFormat {}
  implicit lazy val _BoundParameterTypeSpecifierFormat: scalaxb.XMLFormat[BoundParameterTypeSpecifier] = new Default_BoundParameterTypeSpecifierFormat {}
  implicit lazy val _TypeParameterInfoFormat: scalaxb.XMLFormat[TypeParameterInfo] = new Default_TypeParameterInfoFormat {}
  implicit lazy val _TupleTypeSpecifierElementFormat: scalaxb.XMLFormat[TupleTypeSpecifierElement] = new Default_TupleTypeSpecifierElementFormat {}
  implicit lazy val _TupleTypeSpecifierFormat: scalaxb.XMLFormat[TupleTypeSpecifier] = new Default_TupleTypeSpecifierFormat {}


  implicit val fromAnySchemaType: scala.xml.Elem => Option[scalaxb.DataRecord[Any]] = {elem =>
    import scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("modelInfo"), Some("urn:hl7-org:elm-modelinfo:r1") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[ModelInfo](elem)))

      case _ => None
    }

  }

  trait Default_ContextInfoFormat extends scalaxb.ElemNameParser[ContextInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ContextInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ContextInfo] =
      phrase((scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "contextType")) ^^
      { case p1 =>
      ContextInfo(scalaxb.fromXML[NamedTypeSpecifier](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@keyElement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@keyElement" -> _ },
        (node \ "@birthDateElement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@birthDateElement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ContextInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@keyElement", _) => __obj.keyElement foreach { x => attr = scala.xml.Attribute(null, "keyElement", x.toString, attr) }
        case ("@birthDateElement", _) => __obj.birthDateElement foreach { x => attr = scala.xml.Attribute(null, "birthDateElement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ContextInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[NamedTypeSpecifier](__obj.contextType, Some("urn:hl7-org:elm-modelinfo:r1"), Some("contextType"), __scope, false))
  }

  trait Default_RelationshipInfoFormat extends scalaxb.XMLFormat[RelationshipInfo] with scalaxb.CanWriteChildNodes[RelationshipInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, RelationshipInfo] = seq match {
      case node: scala.xml.Node => Right(RelationshipInfo(scala.collection.immutable.ListMap(List(
        (node \ "@context").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@context" -> _ },
        (node \ "@relatedKeyElement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@relatedKeyElement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: RelationshipInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@context", _) => attr = scala.xml.Attribute(null, "context", __obj.context.toString, attr)
        case ("@relatedKeyElement", _) => __obj.relatedKeyElement foreach { x => attr = scala.xml.Attribute(null, "relatedKeyElement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: RelationshipInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_SearchInfoFormat extends scalaxb.ElemNameParser[SearchInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("SearchInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SearchInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "typeSpecifier")) ^^
      { case p1 =>
      SearchInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@path").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@path" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@label").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@label" -> _ },
        (node \ "@description").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@description" -> _ },
        (node \ "@definition").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@definition" -> _ },
        (node \ "@comment").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@comment" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SearchInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@path", _) => attr = scala.xml.Attribute(null, "path", __obj.path.toString, attr)
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@label", _) => __obj.label foreach { x => attr = scala.xml.Attribute(null, "label", x.toString, attr) }
        case ("@description", _) => __obj.description foreach { x => attr = scala.xml.Attribute(null, "description", x.toString, attr) }
        case ("@definition", _) => __obj.definition foreach { x => attr = scala.xml.Attribute(null, "definition", x.toString, attr) }
        case ("@comment", _) => __obj.comment foreach { x => attr = scala.xml.Attribute(null, "comment", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SearchInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.typeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("typeSpecifier"), __scope, false) } getOrElse {Nil})
  }

  trait Default_ModelInfoFormat extends scalaxb.ElemNameParser[ModelInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ModelInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ModelInfo] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "requiredModelInfo")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "typeInfo")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "conversionInfo")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "contextInfo")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ModelInfo(p1 map { scalaxb.fromXML[ModelSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[TypeInfo](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[ConversionInfo](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[ContextInfo](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ },
        (node \ "@url").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@url" -> _ },
        (node \ "@targetUrl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@targetUrl" -> _ },
        (node \ "@targetVersion").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@targetVersion" -> _ },
        (node \ "@schemaLocation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@schemaLocation" -> _ },
        (node \ "@targetQualifier").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@targetQualifier" -> _ },
        (node \ "@patientClassName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@patientClassName" -> _ },
        (node \ "@patientClassIdentifier").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@patientClassIdentifier" -> _ },
        (node \ "@patientBirthDatePropertyName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@patientBirthDatePropertyName" -> _ },
        (node \ "@caseSensitive").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@caseSensitive" -> _ },
        (node \ "@strictRetrieveTyping").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@strictRetrieveTyping" -> _ },
        (node \ "@defaultContext").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@defaultContext" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ModelInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@version", _) => __obj.version foreach { x => attr = scala.xml.Attribute(null, "version", x.toString, attr) }
        case ("@url", _) => attr = scala.xml.Attribute(null, "url", __obj.url.toString, attr)
        case ("@targetUrl", _) => __obj.targetUrl foreach { x => attr = scala.xml.Attribute(null, "targetUrl", x.toString, attr) }
        case ("@targetVersion", _) => __obj.targetVersion foreach { x => attr = scala.xml.Attribute(null, "targetVersion", x.toString, attr) }
        case ("@schemaLocation", _) => __obj.schemaLocation foreach { x => attr = scala.xml.Attribute(null, "schemaLocation", x.toString, attr) }
        case ("@targetQualifier", _) => __obj.targetQualifier foreach { x => attr = scala.xml.Attribute(null, "targetQualifier", x.toString, attr) }
        case ("@patientClassName", _) => __obj.patientClassName foreach { x => attr = scala.xml.Attribute(null, "patientClassName", x.toString, attr) }
        case ("@patientClassIdentifier", _) => __obj.patientClassIdentifier foreach { x => attr = scala.xml.Attribute(null, "patientClassIdentifier", x.toString, attr) }
        case ("@patientBirthDatePropertyName", _) => __obj.patientBirthDatePropertyName foreach { x => attr = scala.xml.Attribute(null, "patientBirthDatePropertyName", x.toString, attr) }
        case ("@caseSensitive", _) => __obj.caseSensitive foreach { x => attr = scala.xml.Attribute(null, "caseSensitive", x.toString, attr) }
        case ("@strictRetrieveTyping", _) => __obj.strictRetrieveTyping foreach { x => attr = scala.xml.Attribute(null, "strictRetrieveTyping", x.toString, attr) }
        case ("@defaultContext", _) => __obj.defaultContext foreach { x => attr = scala.xml.Attribute(null, "defaultContext", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ModelInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.requiredModelInfo flatMap { scalaxb.toXML[ModelSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("requiredModelInfo"), __scope, false) },
        __obj.typeInfo flatMap { scalaxb.toXML[TypeInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("typeInfo"), __scope, false) },
        __obj.conversionInfo flatMap { scalaxb.toXML[ConversionInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("conversionInfo"), __scope, false) },
        __obj.contextInfo flatMap { scalaxb.toXML[ContextInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("contextInfo"), __scope, false) })

  }

  def build_BindingStrengthFormat = new Default_BindingStrengthFormat {}
  trait Default_BindingStrengthFormat extends scalaxb.XMLFormat[BindingStrength] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): BindingStrength =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, BindingStrength] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Required")) => Required
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Extensible")) => Extensible
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Preferred")) => Preferred
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Example")) => Example

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, BindingStrength] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: BindingStrength, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait Default_BindingInfoFormat extends scalaxb.XMLFormat[BindingInfo] with scalaxb.CanWriteChildNodes[BindingInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, BindingInfo] = seq match {
      case node: scala.xml.Node => Right(BindingInfo(scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@description").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@description" -> _ },
        (node \ "@strength").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BindingStrength](x, scalaxb.ElemName(node) :: stack)) } map { "@strength" -> _ },
        (node \ "@valueSet").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@valueSet" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: BindingInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@description", _) => __obj.description foreach { x => attr = scala.xml.Attribute(null, "description", x.toString, attr) }
        case ("@strength", _) => attr = scala.xml.Attribute(null, "strength", __obj.strength.toString, attr)
        case ("@valueSet", _) => attr = scala.xml.Attribute(null, "valueSet", __obj.valueSet.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BindingInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_ClassInfoElementFormat extends scalaxb.ElemNameParser[ClassInfoElement] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ClassInfoElement")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ClassInfoElement] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "typeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "elementTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "binding")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "constraint")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      ClassInfoElement(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[BindingInfo](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[ConstraintInfo](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@elementType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@elementType" -> _ },
        (node \ "@prohibited").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@prohibited" -> _ },
        (node \ "@oneBased").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@oneBased" -> _ },
        (node \ "@target").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@target" -> _ },
        (node \ "@label").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@label" -> _ },
        (node \ "@description").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@description" -> _ },
        (node \ "@definition").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@definition" -> _ },
        (node \ "@comment").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@comment" -> _ },
        (node \ "@min").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@min" -> _ },
        (node \ "@max").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@max" -> _ },
        (node \ "@mustSupport").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@mustSupport" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ClassInfoElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@elementType", _) => __obj.elementType foreach { x => attr = scala.xml.Attribute(null, "elementType", x.toString, attr) }
        case ("@prohibited", _) => __obj.prohibited foreach { x => attr = scala.xml.Attribute(null, "prohibited", x.toString, attr) }
        case ("@oneBased", _) => __obj.oneBased foreach { x => attr = scala.xml.Attribute(null, "oneBased", x.toString, attr) }
        case ("@target", _) => __obj.target foreach { x => attr = scala.xml.Attribute(null, "target", x.toString, attr) }
        case ("@label", _) => __obj.label foreach { x => attr = scala.xml.Attribute(null, "label", x.toString, attr) }
        case ("@description", _) => __obj.description foreach { x => attr = scala.xml.Attribute(null, "description", x.toString, attr) }
        case ("@definition", _) => __obj.definition foreach { x => attr = scala.xml.Attribute(null, "definition", x.toString, attr) }
        case ("@comment", _) => __obj.comment foreach { x => attr = scala.xml.Attribute(null, "comment", x.toString, attr) }
        case ("@min", _) => __obj.min foreach { x => attr = scala.xml.Attribute(null, "min", x.toString, attr) }
        case ("@max", _) => __obj.max foreach { x => attr = scala.xml.Attribute(null, "max", x.toString, attr) }
        case ("@mustSupport", _) => __obj.mustSupport foreach { x => attr = scala.xml.Attribute(null, "mustSupport", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ClassInfoElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.typeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("typeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.elementTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("elementTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.binding map { scalaxb.toXML[BindingInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("binding"), __scope, false) } getOrElse {Nil},
        __obj.constraint flatMap { scalaxb.toXML[ConstraintInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("constraint"), __scope, false) })

  }

  trait Default_ExpressionInfoFormat extends scalaxb.XMLFormat[ExpressionInfo] with scalaxb.CanWriteChildNodes[ExpressionInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ExpressionInfo] = seq match {
      case node: scala.xml.Node => Right(ExpressionInfo(scala.collection.immutable.ListMap(List(
        (node \ "@language").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@language" -> _ },
        (node \ "@expression").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@expression" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ExpressionInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@language", _) => attr = scala.xml.Attribute(null, "language", __obj.language.toString, attr)
        case ("@expression", _) => attr = scala.xml.Attribute(null, "expression", __obj.expression.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ExpressionInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_ConstraintInfoFormat extends scalaxb.ElemNameParser[ConstraintInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ConstraintInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConstraintInfo] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "expression")) ^^
      { case p1 =>
      ConstraintInfo(p1 map { scalaxb.fromXML[ExpressionInfo](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@severity").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@severity" -> _ },
        (node \ "@description").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@description" -> _ },
        (node \ "@message").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@message" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConstraintInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@severity", _) => attr = scala.xml.Attribute(null, "severity", __obj.severity.toString, attr)
        case ("@description", _) => __obj.description foreach { x => attr = scala.xml.Attribute(null, "description", x.toString, attr) }
        case ("@message", _) => __obj.message foreach { x => attr = scala.xml.Attribute(null, "message", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConstraintInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.expression flatMap { scalaxb.toXML[ExpressionInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("expression"), __scope, false) })
  }

  trait Default_ClassInfoableFormat extends scalaxb.XMLFormat[ClassInfoable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ClassInfoable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("ProfileInfo")) => Right(scalaxb.fromXML[ProfileInfo](node, stack))
          case _ => Right(scalaxb.fromXML[ClassInfo](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: ClassInfoable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: ProfileInfo => scalaxb.toXML[ProfileInfo](x, __namespace, __elementLabel, __scope, true)
      case x: ClassInfo => scalaxb.toXML[ClassInfo](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait Default_ClassInfoFormat extends scalaxb.ElemNameParser[ClassInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ClassInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ClassInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "baseTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "parameter")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "element")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "contextRelationship")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "targetContextRelationship")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "search")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "inferenceExpression")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "constraint")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      ClassInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[TypeParameterInfo](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[ClassInfoElement](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[RelationshipInfo](_, scalaxb.ElemName(node) :: stack) },
        p5 map { scalaxb.fromXML[RelationshipInfo](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[SearchInfo](_, scalaxb.ElemName(node) :: stack) },
        p7 map { scalaxb.fromXML[ExpressionInfo](_, scalaxb.ElemName(node) :: stack) },
        p8 map { scalaxb.fromXML[ConstraintInfo](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@baseType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@baseType" -> _ },
        (node \ "@namespace").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@namespace" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@identifier").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@identifier" -> _ },
        (node \ "@label").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@label" -> _ },
        (node \ "@description").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@description" -> _ },
        (node \ "@definition").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@definition" -> _ },
        (node \ "@comment").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@comment" -> _ },
        (node \ "@target").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@target" -> _ },
        (node \ "@retrievable").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@retrievable" -> _ },
        (node \ "@primaryCodePath").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@primaryCodePath" -> _ },
        (node \ "@primaryValueSetPath").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@primaryValueSetPath" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ClassInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@baseType", _) => __obj.baseType foreach { x => attr = scala.xml.Attribute(null, "baseType", x.toString, attr) }
        case ("@namespace", _) => __obj.namespace foreach { x => attr = scala.xml.Attribute(null, "namespace", x.toString, attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@identifier", _) => __obj.identifier foreach { x => attr = scala.xml.Attribute(null, "identifier", x.toString, attr) }
        case ("@label", _) => __obj.label foreach { x => attr = scala.xml.Attribute(null, "label", x.toString, attr) }
        case ("@description", _) => __obj.description foreach { x => attr = scala.xml.Attribute(null, "description", x.toString, attr) }
        case ("@definition", _) => __obj.definition foreach { x => attr = scala.xml.Attribute(null, "definition", x.toString, attr) }
        case ("@comment", _) => __obj.comment foreach { x => attr = scala.xml.Attribute(null, "comment", x.toString, attr) }
        case ("@target", _) => __obj.target foreach { x => attr = scala.xml.Attribute(null, "target", x.toString, attr) }
        case ("@retrievable", _) => if (__obj.retrievable.toString != "false") attr = scala.xml.Attribute(null, "retrievable", __obj.retrievable.toString, attr)
        case ("@primaryCodePath", _) => __obj.primaryCodePath foreach { x => attr = scala.xml.Attribute(null, "primaryCodePath", x.toString, attr) }
        case ("@primaryValueSetPath", _) => __obj.primaryValueSetPath foreach { x => attr = scala.xml.Attribute(null, "primaryValueSetPath", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ClassInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.baseTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("baseTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.parameter flatMap { scalaxb.toXML[TypeParameterInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("parameter"), __scope, false) },
        __obj.element flatMap { scalaxb.toXML[ClassInfoElement](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("element"), __scope, false) },
        __obj.contextRelationship flatMap { scalaxb.toXML[RelationshipInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("contextRelationship"), __scope, false) },
        __obj.targetContextRelationship flatMap { scalaxb.toXML[RelationshipInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("targetContextRelationship"), __scope, false) },
        __obj.search flatMap { scalaxb.toXML[SearchInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("search"), __scope, false) },
        __obj.inferenceExpression flatMap { scalaxb.toXML[ExpressionInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("inferenceExpression"), __scope, false) },
        __obj.constraint flatMap { scalaxb.toXML[ConstraintInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("constraint"), __scope, false) })

  }

  trait Default_TypeInfoFormat extends scalaxb.XMLFormat[TypeInfo] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, TypeInfo] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("ChoiceTypeInfo")) => Right(scalaxb.fromXML[ChoiceTypeInfo](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("IntervalTypeInfo")) => Right(scalaxb.fromXML[IntervalTypeInfo](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("ClassInfo")) => Right(scalaxb.fromXML[ClassInfoable](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("ProfileInfo")) => Right(scalaxb.fromXML[ProfileInfo](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("SimpleTypeInfo")) => Right(scalaxb.fromXML[SimpleTypeInfo](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("ListTypeInfo")) => Right(scalaxb.fromXML[ListTypeInfo](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("TupleTypeInfo")) => Right(scalaxb.fromXML[TupleTypeInfo](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: TypeInfo, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: ChoiceTypeInfo => scalaxb.toXML[ChoiceTypeInfo](x, __namespace, __elementLabel, __scope, true)
      case x: IntervalTypeInfo => scalaxb.toXML[IntervalTypeInfo](x, __namespace, __elementLabel, __scope, true)
      case x: ClassInfoable => scalaxb.toXML[ClassInfoable](x, __namespace, __elementLabel, __scope, true)
      case x: SimpleTypeInfo => scalaxb.toXML[SimpleTypeInfo](x, __namespace, __elementLabel, __scope, true)
      case x: ListTypeInfo => scalaxb.toXML[ListTypeInfo](x, __namespace, __elementLabel, __scope, true)
      case x: TupleTypeInfo => scalaxb.toXML[TupleTypeInfo](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_SimpleTypeInfoFormat extends scalaxb.ElemNameParser[SimpleTypeInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("SimpleTypeInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[SimpleTypeInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "baseTypeSpecifier")) ^^
      { case p1 =>
      SimpleTypeInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@baseType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@baseType" -> _ },
        (node \ "@namespace").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@namespace" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@target").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@target" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: SimpleTypeInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@baseType", _) => __obj.baseType foreach { x => attr = scala.xml.Attribute(null, "baseType", x.toString, attr) }
        case ("@namespace", _) => __obj.namespace foreach { x => attr = scala.xml.Attribute(null, "namespace", x.toString, attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@target", _) => __obj.target foreach { x => attr = scala.xml.Attribute(null, "target", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: SimpleTypeInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.baseTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("baseTypeSpecifier"), __scope, false) } getOrElse {Nil})
  }

  trait Default_IntervalTypeInfoFormat extends scalaxb.ElemNameParser[IntervalTypeInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("IntervalTypeInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IntervalTypeInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "baseTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "pointTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      IntervalTypeInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@baseType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@baseType" -> _ },
        (node \ "@pointType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@pointType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IntervalTypeInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@baseType", _) => __obj.baseType foreach { x => attr = scala.xml.Attribute(null, "baseType", x.toString, attr) }
        case ("@pointType", _) => __obj.pointType foreach { x => attr = scala.xml.Attribute(null, "pointType", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IntervalTypeInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.baseTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("baseTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.pointTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("pointTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ListTypeInfoFormat extends scalaxb.ElemNameParser[ListTypeInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ListTypeInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ListTypeInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "baseTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "elementTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ListTypeInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@baseType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@baseType" -> _ },
        (node \ "@elementType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@elementType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ListTypeInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@baseType", _) => __obj.baseType foreach { x => attr = scala.xml.Attribute(null, "baseType", x.toString, attr) }
        case ("@elementType", _) => __obj.elementType foreach { x => attr = scala.xml.Attribute(null, "elementType", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ListTypeInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.baseTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("baseTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.elementTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("elementTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_TupleTypeInfoElementFormat extends scalaxb.ElemNameParser[TupleTypeInfoElement] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("TupleTypeInfoElement")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TupleTypeInfoElement] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "typeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "elementTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      TupleTypeInfoElement(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@elementType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@elementType" -> _ },
        (node \ "@prohibited").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@prohibited" -> _ },
        (node \ "@oneBased").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@oneBased" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TupleTypeInfoElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@elementType", _) => __obj.elementType foreach { x => attr = scala.xml.Attribute(null, "elementType", x.toString, attr) }
        case ("@prohibited", _) => __obj.prohibited foreach { x => attr = scala.xml.Attribute(null, "prohibited", x.toString, attr) }
        case ("@oneBased", _) => __obj.oneBased foreach { x => attr = scala.xml.Attribute(null, "oneBased", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TupleTypeInfoElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.typeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("typeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.elementTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("elementTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_TupleTypeInfoFormat extends scalaxb.ElemNameParser[TupleTypeInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("TupleTypeInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TupleTypeInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "baseTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "element")) ^^
      { case p1 ~ p2 =>
      TupleTypeInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[TupleTypeInfoElement](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@baseType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@baseType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TupleTypeInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@baseType", _) => __obj.baseType foreach { x => attr = scala.xml.Attribute(null, "baseType", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TupleTypeInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.baseTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("baseTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.element flatMap { scalaxb.toXML[TupleTypeInfoElement](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("element"), __scope, false) })

  }

  trait Default_ProfileInfoFormat extends scalaxb.ElemNameParser[ProfileInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ProfileInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ProfileInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "baseTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "parameter")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "element")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "contextRelationship")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "targetContextRelationship")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "search")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "inferenceExpression")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "constraint")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      ProfileInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[TypeParameterInfo](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[ClassInfoElement](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[RelationshipInfo](_, scalaxb.ElemName(node) :: stack) },
        p5 map { scalaxb.fromXML[RelationshipInfo](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[SearchInfo](_, scalaxb.ElemName(node) :: stack) },
        p7 map { scalaxb.fromXML[ExpressionInfo](_, scalaxb.ElemName(node) :: stack) },
        p8 map { scalaxb.fromXML[ConstraintInfo](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@baseType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@baseType" -> _ },
        (node \ "@namespace").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@namespace" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@identifier").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@identifier" -> _ },
        (node \ "@label").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@label" -> _ },
        (node \ "@description").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@description" -> _ },
        (node \ "@definition").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@definition" -> _ },
        (node \ "@comment").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@comment" -> _ },
        (node \ "@target").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@target" -> _ },
        (node \ "@retrievable").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack))) map { "@retrievable" -> _ },
        (node \ "@primaryCodePath").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@primaryCodePath" -> _ },
        (node \ "@primaryValueSetPath").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@primaryValueSetPath" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ProfileInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@baseType", _) => __obj.baseType foreach { x => attr = scala.xml.Attribute(null, "baseType", x.toString, attr) }
        case ("@namespace", _) => __obj.namespace foreach { x => attr = scala.xml.Attribute(null, "namespace", x.toString, attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@identifier", _) => __obj.identifier foreach { x => attr = scala.xml.Attribute(null, "identifier", x.toString, attr) }
        case ("@label", _) => __obj.label foreach { x => attr = scala.xml.Attribute(null, "label", x.toString, attr) }
        case ("@description", _) => __obj.description foreach { x => attr = scala.xml.Attribute(null, "description", x.toString, attr) }
        case ("@definition", _) => __obj.definition foreach { x => attr = scala.xml.Attribute(null, "definition", x.toString, attr) }
        case ("@comment", _) => __obj.comment foreach { x => attr = scala.xml.Attribute(null, "comment", x.toString, attr) }
        case ("@target", _) => __obj.target foreach { x => attr = scala.xml.Attribute(null, "target", x.toString, attr) }
        case ("@retrievable", _) => if (__obj.retrievable.toString != "false") attr = scala.xml.Attribute(null, "retrievable", __obj.retrievable.toString, attr)
        case ("@primaryCodePath", _) => __obj.primaryCodePath foreach { x => attr = scala.xml.Attribute(null, "primaryCodePath", x.toString, attr) }
        case ("@primaryValueSetPath", _) => __obj.primaryValueSetPath foreach { x => attr = scala.xml.Attribute(null, "primaryValueSetPath", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ProfileInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.baseTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("baseTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.parameter flatMap { scalaxb.toXML[TypeParameterInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("parameter"), __scope, false) },
        __obj.element flatMap { scalaxb.toXML[ClassInfoElement](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("element"), __scope, false) },
        __obj.contextRelationship flatMap { scalaxb.toXML[RelationshipInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("contextRelationship"), __scope, false) },
        __obj.targetContextRelationship flatMap { scalaxb.toXML[RelationshipInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("targetContextRelationship"), __scope, false) },
        __obj.search flatMap { scalaxb.toXML[SearchInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("search"), __scope, false) },
        __obj.inferenceExpression flatMap { scalaxb.toXML[ExpressionInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("inferenceExpression"), __scope, false) },
        __obj.constraint flatMap { scalaxb.toXML[ConstraintInfo](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("constraint"), __scope, false) })

  }

  trait Default_ConversionInfoFormat extends scalaxb.ElemNameParser[ConversionInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ConversionInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ConversionInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "fromTypeSpecifier")) ~ 
      opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "toTypeSpecifier")) ^^
      { case p1 ~ p2 =>
      ConversionInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@functionName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@functionName" -> _ },
        (node \ "@fromType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@fromType" -> _ },
        (node \ "@toType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@toType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ConversionInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@functionName", _) => attr = scala.xml.Attribute(null, "functionName", __obj.functionName.toString, attr)
        case ("@fromType", _) => __obj.fromType foreach { x => attr = scala.xml.Attribute(null, "fromType", x.toString, attr) }
        case ("@toType", _) => __obj.toType foreach { x => attr = scala.xml.Attribute(null, "toType", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ConversionInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.fromTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("fromTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.toTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("toTypeSpecifier"), __scope, false) } getOrElse {Nil})

  }

  trait Default_ChoiceTypeInfoFormat extends scalaxb.ElemNameParser[ChoiceTypeInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ChoiceTypeInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ChoiceTypeInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "baseTypeSpecifier")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "type")) ~ 
      safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "choice")) ^^
      { case p1 ~ p2 ~ p3 =>
      ChoiceTypeInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@baseType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@baseType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ChoiceTypeInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@baseType", _) => __obj.baseType foreach { x => attr = scala.xml.Attribute(null, "baseType", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ChoiceTypeInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.baseTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("baseTypeSpecifier"), __scope, false) } getOrElse {Nil},
        __obj.typeValue flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("type"), __scope, false) },
        __obj.choice flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("choice"), __scope, false) })

  }

  trait Default_ModelSpecifierFormat extends scalaxb.XMLFormat[ModelSpecifier] with scalaxb.CanWriteChildNodes[ModelSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ModelSpecifier] = seq match {
      case node: scala.xml.Node => Right(ModelSpecifier(scala.collection.immutable.ListMap(List(
        (node \ "@url").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@url" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ModelSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@url", _) => __obj.url foreach { x => attr = scala.xml.Attribute(null, "url", x.toString, attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@version", _) => __obj.version foreach { x => attr = scala.xml.Attribute(null, "version", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ModelSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_TypeSpecifierFormat extends scalaxb.XMLFormat[TypeSpecifier] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, TypeSpecifier] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("BoundParameterTypeSpecifier")) => Right(scalaxb.fromXML[BoundParameterTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("ChoiceTypeSpecifier")) => Right(scalaxb.fromXML[ChoiceTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("ListTypeSpecifier")) => Right(scalaxb.fromXML[ListTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("NamedTypeSpecifier")) => Right(scalaxb.fromXML[NamedTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("IntervalTypeSpecifier")) => Right(scalaxb.fromXML[IntervalTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("ParameterTypeSpecifier")) => Right(scalaxb.fromXML[ParameterTypeSpecifier](node, stack))
          case (Some("urn:hl7-org:elm-modelinfo:r1"), Some("TupleTypeSpecifier")) => Right(scalaxb.fromXML[TupleTypeSpecifier](node, stack))
          case x => Left("Unknown type: " + x)
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: TypeSpecifier, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: BoundParameterTypeSpecifier => scalaxb.toXML[BoundParameterTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: ChoiceTypeSpecifier => scalaxb.toXML[ChoiceTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: ListTypeSpecifier => scalaxb.toXML[ListTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: NamedTypeSpecifier => scalaxb.toXML[NamedTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: IntervalTypeSpecifier => scalaxb.toXML[IntervalTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: ParameterTypeSpecifier => scalaxb.toXML[ParameterTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case x: TupleTypeSpecifier => scalaxb.toXML[TupleTypeSpecifier](x, __namespace, __elementLabel, __scope, true)
      case _ => sys.error("Unknown type: " + __obj)
    }
  }

  trait Default_NamedTypeSpecifierFormat extends scalaxb.XMLFormat[NamedTypeSpecifier] with scalaxb.CanWriteChildNodes[NamedTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, NamedTypeSpecifier] = seq match {
      case node: scala.xml.Node => Right(NamedTypeSpecifier(scala.collection.immutable.ListMap(List(
        (node \ "@modelName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@modelName" -> _ },
        (node \ "@namespace").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@namespace" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: NamedTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@modelName", _) => __obj.modelName foreach { x => attr = scala.xml.Attribute(null, "modelName", x.toString, attr) }
        case ("@namespace", _) => __obj.namespace foreach { x => attr = scala.xml.Attribute(null, "namespace", x.toString, attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: NamedTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_ListTypeSpecifierFormat extends scalaxb.ElemNameParser[ListTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ListTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ListTypeSpecifier] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "elementTypeSpecifier")) ^^
      { case p1 =>
      ListTypeSpecifier(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@elementType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@elementType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: ListTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@elementType", _) => __obj.elementType foreach { x => attr = scala.xml.Attribute(null, "elementType", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ListTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.elementTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("elementTypeSpecifier"), __scope, false) } getOrElse {Nil})
  }

  trait Default_IntervalTypeSpecifierFormat extends scalaxb.ElemNameParser[IntervalTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("IntervalTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[IntervalTypeSpecifier] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "pointTypeSpecifier")) ^^
      { case p1 =>
      IntervalTypeSpecifier(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@pointType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@pointType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: IntervalTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@pointType", _) => __obj.pointType foreach { x => attr = scala.xml.Attribute(null, "pointType", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: IntervalTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.pointTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("pointTypeSpecifier"), __scope, false) } getOrElse {Nil})
  }

  trait Default_ChoiceTypeSpecifierFormat extends scalaxb.ElemNameParser[ChoiceTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("ChoiceTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[ChoiceTypeSpecifier] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "choice")) ^^
      { case p1 =>
      ChoiceTypeSpecifier(p1 map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: ChoiceTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.choice flatMap { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("choice"), __scope, false) })
  }

  trait Default_ParameterTypeSpecifierFormat extends scalaxb.XMLFormat[ParameterTypeSpecifier] with scalaxb.CanWriteChildNodes[ParameterTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, ParameterTypeSpecifier] = seq match {
      case node: scala.xml.Node => Right(ParameterTypeSpecifier(scala.collection.immutable.ListMap(List(
        (node \ "@parameterName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@parameterName" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: ParameterTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@parameterName", _) => attr = scala.xml.Attribute(null, "parameterName", __obj.parameterName.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: ParameterTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait Default_BoundParameterTypeSpecifierFormat extends scalaxb.ElemNameParser[BoundParameterTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("BoundParameterTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[BoundParameterTypeSpecifier] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "elementTypeSpecifier")) ^^
      { case p1 =>
      BoundParameterTypeSpecifier(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@parameterName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@parameterName" -> _ },
        (node \ "@boundType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@boundType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: BoundParameterTypeSpecifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@parameterName", _) => attr = scala.xml.Attribute(null, "parameterName", __obj.parameterName.toString, attr)
        case ("@boundType", _) => attr = scala.xml.Attribute(null, "boundType", __obj.boundType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: BoundParameterTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.elementTypeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("elementTypeSpecifier"), __scope, false) } getOrElse {Nil})
  }

  trait Default_TypeParameterInfoFormat extends scalaxb.ElemNameParser[TypeParameterInfo] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("TypeParameterInfo")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TypeParameterInfo] =
      phrase(opt(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "typeSpecifier")) ^^
      { case p1 =>
      TypeParameterInfo(p1.headOption map { scalaxb.fromXML[TypeSpecifier](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@constraint").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@constraint" -> _ },
        (node \ "@constraintType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@constraintType" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TypeParameterInfo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@constraint", _) => attr = scala.xml.Attribute(null, "constraint", __obj.constraint.toString, attr)
        case ("@constraintType", _) => __obj.constraintType foreach { x => attr = scala.xml.Attribute(null, "constraintType", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TypeParameterInfo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.typeSpecifier map { scalaxb.toXML[TypeSpecifier](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("typeSpecifier"), __scope, false) } getOrElse {Nil})
  }

  trait Default_TupleTypeSpecifierElementFormat extends scalaxb.ElemNameParser[TupleTypeSpecifierElement] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("TupleTypeSpecifierElement")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TupleTypeSpecifierElement] =
      phrase((scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "elementType")) ^^
      { case p1 =>
      TupleTypeSpecifierElement(scalaxb.fromXML[TypeSpecifier](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: TupleTypeSpecifierElement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: TupleTypeSpecifierElement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[TypeSpecifier](__obj.elementType, Some("urn:hl7-org:elm-modelinfo:r1"), Some("elementType"), __scope, false))
  }

  trait Default_TupleTypeSpecifierFormat extends scalaxb.ElemNameParser[TupleTypeSpecifier] {
    val targetNamespace: Option[String] = Some("urn:hl7-org:elm-modelinfo:r1")
    
    override def typeName: Option[String] = Some("TupleTypeSpecifier")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[TupleTypeSpecifier] =
      phrase(safeRep(scalaxb.ElemName(Some("urn:hl7-org:elm-modelinfo:r1"), "element")) ^^
      { case p1 =>
      TupleTypeSpecifier(p1 map { scalaxb.fromXML[TupleTypeSpecifierElement](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: TupleTypeSpecifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.element flatMap { scalaxb.toXML[TupleTypeSpecifierElement](_, Some("urn:hl7-org:elm-modelinfo:r1"), Some("element"), __scope, false) })
  }


}

